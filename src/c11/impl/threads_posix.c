   /*
   * C11 <threads.h> emulation library
   *
   * (C) Copyright yohhoy 2012.
   * Distributed under the Boost Software License, Version 1.0.
   *
   * Permission is hereby granted, free of charge, to any person or organization
   * obtaining a copy of the software and accompanying documentation covered by
   * this license (the "Software") to use, reproduce, display, distribute,
   * execute, and transmit the Software, and to prepare [[derivative work]]s of the
   * Software, and to permit third-parties to whom the Software is furnished to
   * do so, all subject to the following:
   *
   * The copyright notices in the Software and this entire statement, including
   * the above license grant, this restriction and the following disclaimer,
   * must be included in all copies of the Software, in whole or in part, and
   * all derivative works of the Software, unless such copies or derivative
   * works are solely in the form of machine-executable object code generated by
   * a source language processor.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
   * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
   * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   * DEALINGS IN THE SOFTWARE.
   */
   #include <stdlib.h>
   #include <assert.h>
   #include <limits.h>
   #include <errno.h>
   #include <unistd.h>
   #include <sched.h>
   #include <stdint.h> /* for intptr_t */
      #include "c11/threads.h"
      /*
   Configuration macro:
      EMULATED_THREADS_USE_NATIVE_TIMEDLOCK
      Use pthread_mutex_timedlock() for `mtx_timedlock()'
      */
   #if !defined(__CYGWIN__) && !defined(__APPLE__) && !defined(__NetBSD__)
   #define EMULATED_THREADS_USE_NATIVE_TIMEDLOCK
   #endif
      /*---------------------------- types ----------------------------*/
      /*
   Implementation limits:
   - Conditionally emulation for "mutex with timeout"
         */
   struct impl_thrd_param {
      thrd_start_t func;
      };
      static void *
   impl_thrd_routine(void *p)
   {
      struct impl_thrd_param pack = *((struct impl_thrd_param *)p);
   free(p);
      }
         /*--------------- 7.25.2 Initialization functions ---------------*/
   // 7.25.2.1
   void
   call_once(once_flag *flag, void (*func)(void))
   {
         }
         /*------------- 7.25.3 Condition variable functions -------------*/
   // 7.25.3.1
   int
   cnd_broadcast(cnd_t *cond)
   {
      assert(cond != NULL);
      }
      // 7.25.3.2
   void
   cnd_destroy(cnd_t *cond)
   {
      assert(cond);
      }
      // 7.25.3.3
   int
   cnd_init(cnd_t *cond)
   {
      assert(cond != NULL);
      }
      // 7.25.3.4
   int
   cnd_signal(cnd_t *cond)
   {
      assert(cond != NULL);
      }
      // 7.25.3.5
   int
   cnd_timedwait(cnd_t *cond, mtx_t *mtx, const struct timespec *abs_time)
   {
               assert(mtx != NULL);
   assert(cond != NULL);
            rt = pthread_cond_timedwait(cond, mtx, abs_time);
   if (rt == ETIMEDOUT)
            }
      // 7.25.3.6
   int
   cnd_wait(cnd_t *cond, mtx_t *mtx)
   {
      assert(mtx != NULL);
   assert(cond != NULL);
      }
         /*-------------------- 7.25.4 Mutex functions --------------------*/
   // 7.25.4.1
   void
   mtx_destroy(mtx_t *mtx)
   {
      assert(mtx != NULL);
      }
      /*
   * XXX: Workaround when building with -O0 and without pthreads link.
   *
   * In such cases constant folding and dead code elimination won't be
   * available, thus the compiler will always add the pthread_mutexattr*
   * functions into the binary. As we try to link, we'll fail as the
   * symbols are unresolved.
   *
   * Ideally we'll enable the optimisations locally, yet that does not
   * seem to work.
   *
   * So the alternative workaround is to annotate the symbols as weak.
   * Thus the linker will be happy and things don't clash when building
   * with -O1 or greater.
   */
   #if defined(HAVE_FUNC_ATTRIBUTE_WEAK) && !defined(__CYGWIN__)
   __attribute__((weak))
   int pthread_mutexattr_init(pthread_mutexattr_t *attr);
      __attribute__((weak))
   int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
      __attribute__((weak))
   int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
   #endif
      // 7.25.4.2
   int
   mtx_init(mtx_t *mtx, int type)
   {
      pthread_mutexattr_t attr;
   assert(mtx != NULL);
   if (type != mtx_plain && type != mtx_timed
      && type != (mtx_plain|mtx_recursive)
   && type != (mtx_timed|mtx_recursive))
         if ((type & mtx_recursive) == 0) {
      pthread_mutex_init(mtx, NULL);
               pthread_mutexattr_init(&attr);
   pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
   pthread_mutex_init(mtx, &attr);
   pthread_mutexattr_destroy(&attr);
      }
      // 7.25.4.3
   int
   mtx_lock(mtx_t *mtx)
   {
      assert(mtx != NULL);
      }
      static int
   threads_timespec_compare(const struct timespec *a, const struct timespec *b)
   {
      if (a->tv_sec < b->tv_sec) {
         } else if (a->tv_sec > b->tv_sec) {
         } else if (a->tv_nsec < b->tv_nsec) {
         } else if (a->tv_nsec > b->tv_nsec) {
         }
      }
      // 7.25.4.4
   int
   mtx_timedlock(mtx_t *mtx, const struct timespec *ts)
   {
      assert(mtx != NULL);
               #ifdef EMULATED_THREADS_USE_NATIVE_TIMEDLOCK
      int rt;
   rt = pthread_mutex_timedlock(mtx, ts);
   if (rt == 0)
            #else
      while (mtx_trylock(mtx) != thrd_success) {
      struct timespec now;
   if (timespec_get(&now, TIME_UTC) != TIME_UTC) {
         }
   if (threads_timespec_compare(ts, &now) < 0)
         // busy loop!
      }
      #endif
         }
      // 7.25.4.5
   int
   mtx_trylock(mtx_t *mtx)
   {
      assert(mtx != NULL);
      }
      // 7.25.4.6
   int
   mtx_unlock(mtx_t *mtx)
   {
      assert(mtx != NULL);
      }
         /*------------------- 7.25.5 Thread functions -------------------*/
   // 7.25.5.1
   int
   thrd_create(thrd_t *thr, thrd_start_t func, void *arg)
   {
      struct impl_thrd_param *pack;
   assert(thr != NULL);
   pack = (struct impl_thrd_param *)malloc(sizeof(struct impl_thrd_param));
   if (!pack) return thrd_nomem;
   pack->func = func;
   pack->arg = arg;
   if (pthread_create(thr, NULL, impl_thrd_routine, pack) != 0) {
      free(pack);
      }
      }
      // 7.25.5.2
   thrd_t
   thrd_current(void)
   {
         }
      // 7.25.5.3
   int
   thrd_detach(thrd_t thr)
   {
         }
      // 7.25.5.4
   int
   thrd_equal(thrd_t thr0, thrd_t thr1)
   {
         }
      // 7.25.5.5
   _Noreturn
   void
   thrd_exit(int res)
   {
         }
      // 7.25.5.6
   int
   thrd_join(thrd_t thr, int *res)
   {
      void *code;
   if (pthread_join(thr, &code) != 0)
         if (res)
            }
      // 7.25.5.7
   int
   thrd_sleep(const struct timespec *time_point, struct timespec *remaining)
   {
      assert(time_point != NULL);
      }
      // 7.25.5.8
   void
   thrd_yield(void)
   {
         }
         /*----------- 7.25.6 Thread-specific storage functions -----------*/
   // 7.25.6.1
   int
   tss_create(tss_t *key, tss_dtor_t dtor)
   {
      assert(key != NULL);
      }
      // 7.25.6.2
   void
   tss_delete(tss_t key)
   {
         }
      // 7.25.6.3
   void *
   tss_get(tss_t key)
   {
         }
      // 7.25.6.4
   int
   tss_set(tss_t key, void *val)
   {
         }
