   # Copyright © 2017 Intel Corporation
      # Permission is hereby granted, free of charge, to any person obtaining a copy
   # of this software and associated documentation files (the "Software"), to deal
   # in the Software without restriction, including without limitation the rights
   # to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   # copies of the Software, and to permit persons to whom the Software is
   # furnished to do so, subject to the following conditions:
      # The above copyright notice and this permission notice shall be included in
   # all copies or substantial portions of the Software.
      # THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   # IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   # FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   # AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   # LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   # OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   # SOFTWARE.
      """Create enum to string functions for vulkan using vk.xml."""
      import argparse
   import functools
   import os
   import re
   import textwrap
   import xml.etree.ElementTree as et
      from mako.template import Template
   from vk_extensions import Extension, filter_api, get_all_required
      COPYRIGHT = textwrap.dedent(u"""\
      * Copyright © 2017 Intel Corporation
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
         C_TEMPLATE = Template(textwrap.dedent(u"""\
      /* Autogenerated file -- do not edit
   * generated by ${file}
   *
   ${copyright}
            #include <string.h>
   #include <vulkan/vulkan_core.h>
   #include <vulkan/vk_android_native_buffer.h>
   #include <vulkan/vk_layer.h>
   #include "util/macros.h"
                        #ifdef ${enum.guard}
            const char *
   vk_${enum.name[2:]}_to_str(${enum.name} input)
   {
         % for v in sorted(enum.values.keys()):
      case ${v}:
      % endfor
      case ${enum.max_enum_name}: return "${enum.max_enum_name}";
   default:
                        #endif
                                 #ifdef ${enum.guard}
            const char *
   vk_${enum.name[2:]}_to_str(${enum.name} input)
   {
         % for v in sorted(enum.values.keys()):
      case ${v}:
      % endfor
      default:
                        #endif
                     size_t vk_structure_type_size(const struct VkBaseInStructure *item)
   {
         % for struct in structs:
         #ifdef ${struct.extension.define}
         #endif
      % else:
   case ${struct.stype}: return sizeof(${struct.name});
      %endfor
      case VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO: return sizeof(VkLayerInstanceCreateInfo);
   case VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO: return sizeof(VkLayerDeviceCreateInfo);
   default:
                     const char *
   vk_ObjectType_to_ObjectName(VkObjectType type)
   {
         % for object_type in sorted(object_types[0].enum_to_name.keys()):
      case ${object_type}:
      % endfor
      default:
            }
         H_TEMPLATE = Template(textwrap.dedent(u"""\
      /* Autogenerated file -- do not edit
   * generated by ${file}
   *
   ${copyright}
            #ifndef MESA_VK_ENUM_TO_STR_H
            #include <vulkan/vulkan.h>
            #ifdef __cplusplus
   extern "C" {
            % for enum in enums:
      #ifdef ${enum.guard}
            const char * vk_${enum.name[2:]}_to_str(${enum.name} input);
      #endif
                     % for enum in bitmasks:
      #ifdef ${enum.guard}
            const char * vk_${enum.name[2:]}_to_str(${enum.name} input);
      #endif
                                       #ifdef __cplusplus
   } /* extern "C" */
                     H_DEFINE_TEMPLATE = Template(textwrap.dedent(u"""\
      /* Autogenerated file -- do not edit
   * generated by ${file}
   *
   ${copyright}
            #ifndef MESA_VK_ENUM_DEFINES_H
            #include <vulkan/vulkan_core.h>
            #ifdef __cplusplus
   extern "C" {
            % for ext in extensions:
   #define _${ext.name}_number (${ext.number})
            % for enum in bitmasks:
      % if enum.bitwidth > 32:
   <% continue %>
   % endif
   #ifdef ${enum.guard}
            #define ${enum.all_bits_name()} ${hex(enum.all_bits_value())}u
      #endif
                     % for enum in bitmasks:
      % if enum.bitwidth < 64:
   <% continue %>
      /* Redefine bitmask values of ${enum.name} */
      #ifdef ${enum.guard}
         % endif
      #define ${n} (${hex(v)}ULL)
      % endfor
   #endif
                     static inline VkFormatFeatureFlags
   vk_format_features2_to_features(VkFormatFeatureFlags2 features2)
   {
                  #ifdef __cplusplus
   } /* extern "C" */
                     class NamedFactory(object):
               def __init__(self, type_):
      self.registry = {}
         def __call__(self, name, **kwargs):
      try:
         except KeyError:
               def get(self, name):
            class VkExtension(object):
               def __init__(self, name, number=None, define=None):
      self.name = name
   self.number = number
         def CamelCase_to_SHOUT_CASE(s):
            def compute_max_enum_name(s):
      if s == "VkSwapchainImageUsageFlagBitsANDROID":
         max_enum_name = CamelCase_to_SHOUT_CASE(s)
   last_prefix = max_enum_name.rsplit('_', 1)[-1]
   # Those special prefixes need to be always at the end
   if last_prefix in ['AMD', 'EXT', 'INTEL', 'KHR', 'NV', 'LUNARG', 'QCOM', 'MSFT'] :
      max_enum_name = "_".join(max_enum_name.split('_')[:-1])
      else:
                  class VkEnum(object):
               def __init__(self, name, bitwidth=32, values=None):
      self.name = name
   self.max_enum_name = compute_max_enum_name(name)
   self.bitwidth = bitwidth
   self.extension = None
   # Maps numbers to names
   self.values = values or dict()
   self.name_to_value = dict()
   self.guard = None
         def all_bits_name(self):
      assert self.name.startswith('Vk')
                  def all_bits_value(self):
            def add_value(self, name, value=None,
                  if alias is not None:
         assert value is None and offset is None
   if alias not in self.name_to_value:
      # We don't have this alias yet.  Just record the alias and
   # we'll deal with it later.
                              assert value is not None or extnum is not None
   if value is None:
         value = 1000000000 + (extnum - 1) * 1000 + offset
            self.name_to_value[name] = value
   if value not in self.values:
         elif len(self.values[value]) > len(name):
            # Now that the value has been fully added, resolve aliases, if any.
   if name in self.name_to_alias_list:
         for alias in self.name_to_alias_list[name]:
         def add_value_from_xml(self, elem, extension=None):
      self.extension = extension
   if 'value' in elem.attrib:
         self.add_value(elem.attrib['name'],
   elif 'bitpos' in elem.attrib:
         self.add_value(elem.attrib['name'],
   elif 'alias' in elem.attrib:
         else:
         error = 'dir' in elem.attrib and elem.attrib['dir'] == '-'
   if 'extnumber' in elem.attrib:
         else:
         self.add_value(elem.attrib['name'],
               def set_guard(self, g):
            class VkChainStruct(object):
      """Simple struct-like class representing a single Vulkan struct identified with a VkStructureType"""
   def __init__(self, name, stype):
      self.name = name
   self.stype = stype
         def struct_get_stype(xml_node):
      for member in xml_node.findall('./member'):
      name = member.findall('./name')
   if len(name) > 0 and name[0].text == "sType":
            class VkObjectType(object):
      """Simple struct-like class representing a single Vulkan object type"""
   def __init__(self, name):
      self.name = name
         def parse_xml(enum_factory, ext_factory, struct_factory, bitmask_factory,
                     This parser is a memory efficient iterative XML parser that returns a list
   of VkEnum objects.
            xml = et.parse(filename)
                     for enum_type in xml.findall('./enums[@type="enum"]'):
      if not filter_api(enum_type, api):
            type_name = enum_type.attrib['name']
   if not type_name in required_types:
            enum = enum_factory(type_name)
   for value in enum_type.findall('./enum'):
               # For bitmask we only add the Enum selected for convenience.
   for enum_type in xml.findall('./enums[@type="bitmask"]'):
      if not filter_api(enum_type, api):
            type_name = enum_type.attrib['name']
   if not type_name in required_types:
            bitwidth = int(enum_type.attrib.get('bitwidth', 32))
   enum = bitmask_factory(type_name, bitwidth=bitwidth)
   for value in enum_type.findall('./enum'):
               for feature in xml.findall('./feature'):
      if not api in feature.attrib['api'].split(','):
            for value in feature.findall('./require/enum[@extends]'):
         extends = value.attrib['extends']
   enum = enum_factory.get(extends)
   if enum is not None:
         enum = bitmask_factory.get(extends)
         for struct_type in xml.findall('./types/type[@category="struct"]'):
      if not filter_api(struct_type, api):
            name = struct_type.attrib['name']
   if name not in required_types:
            stype = struct_get_stype(struct_type)
   if stype is not None:
         platform_define = {}
   for platform in xml.findall('./platforms/platform'):
      name = platform.attrib['name']
   define = platform.attrib['protect']
         for ext_elem in xml.findall('./extensions/extension'):
      ext = Extension.from_xml(ext_elem)
   if api not in ext.supported:
            define = platform_define.get(ext.platform, None)
            for req_elem in ext_elem.findall('./require'):
                        for value in req_elem.findall('./enum[@extends]'):
      extends = value.attrib['extends']
   enum = enum_factory.get(extends)
   if enum is not None:
                           for t in req_elem.findall('./type'):
                  if define:
         for value in ext_elem.findall('./require/type[@name]'):
      enum = enum_factory.get(value.attrib['name'])
   if enum is not None:
                  obj_type_enum = enum_factory.get("VkObjectType")
   obj_types = obj_type_factory("VkObjectType")
   for object_type in xml.findall('./types/type[@category="handle"]'):
      for object_name in object_type.findall('./name'):
                        # Annoyingly, object types are hard to filter by API so just
   # look for whether or not we can find the enum name in the
   # VkObjectType enum.
                        def main():
      parser = argparse.ArgumentParser()
   parser.add_argument('--beta', required=True, help='Enable beta extensions.')
   parser.add_argument('--xml', required=True,
                     parser.add_argument('--outdir',
                           enum_factory = NamedFactory(VkEnum)
   ext_factory = NamedFactory(VkExtension)
   struct_factory = NamedFactory(VkChainStruct)
   obj_type_factory = NamedFactory(VkObjectType)
            for filename in args.xml_files:
      parse_xml(enum_factory, ext_factory, struct_factory, bitmask_factory,
      enums = sorted(enum_factory.registry.values(), key=lambda e: e.name)
   extensions = sorted(ext_factory.registry.values(), key=lambda e: e.name)
   structs = sorted(struct_factory.registry.values(), key=lambda e: e.name)
   bitmasks = sorted(bitmask_factory.registry.values(), key=lambda e: e.name)
            for template, file_ in [(C_TEMPLATE, os.path.join(args.outdir, 'vk_enum_to_str.c')),
                  with open(file_, 'w', encoding='utf-8') as f:
         f.write(template.render(
      file=os.path.basename(__file__),
   enums=enums,
   extensions=extensions,
   structs=structs,
            if __name__ == '__main__':
      main()
