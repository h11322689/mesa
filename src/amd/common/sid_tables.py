   CopyRight = '''
   /*
   * Copyright 2015-2019 Advanced Micro Devices, Inc.
   *
   * SPDX-License-Identifier: MIT
   */
   '''
      from collections import defaultdict
   import functools
   import itertools
   import json
   import os.path
   import re
   import sys
      AMD_REGISTERS = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), "../registers"))
   sys.path.append(AMD_REGISTERS)
      from regdb import Object, RegisterDatabase
         def string_to_chars(string):
               class StringTable:
      """
   A class for collecting multiple strings in a single larger string that is
   used by indexing (to avoid relocations in the resulting binary)
   """
   def __init__(self):
      self.table = []
         def add(self, string):
      # We might get lucky with string being a suffix of a previously added string
   for te in self.table:
         if te[0].endswith(string):
                  idx = self.length
   self.table.append((string, idx, set((idx,))))
                  def emit(self, filp, name, static=True):
      """
   Write
   [static] const char name[] = "...";
   to filp.
   """
   fragments = [
         '%s /* %s (%s) */' % (
      string_to_chars(te[0].encode('unicode_escape').decode()),
   te[0].encode('unicode_escape').decode(),
      )
   ]
   filp.write('%sconst char %s[] = {\n%s\n};\n' % (
         'static ' if static else '',
   name,
      class IntTable:
      """
   A class for collecting multiple arrays of integers in a single big array
   that is used by indexing (to avoid relocations in the resulting binary)
   """
   def __init__(self, typename):
      self.typename = typename
   self.table = []
         def add(self, array):
      # We might get lucky and find the array somewhere in the existing data
   try:
         idx = 0
                     for i in range(1, len(array)):
      if array[i] != self.table[idx + i]:
                        except ValueError:
            idx = len(self.table)
   self.table += array
   self.idxs.add(idx)
         def emit(self, filp, name, static=True):
      """
   Write
   [static] const typename name[] = { ... };
   to filp.
   """
            fragments = [
         ('\t/* %s */ %s' % (
      idxs[i],
      ))
            filp.write('%sconst %s %s[] = {\n%s\n};\n' % (
         'static ' if static else '',
   self.typename, name,
      class Field:
      def __init__(self, name, bits):
      self.name = name
   self.bits = bits   # [first, last]
         def format(self, string_table, idx_table):
      mask = ((1 << (self.bits[1] - self.bits[0] + 1)) - 1) << self.bits[0]
   if len(self.values):
         values_offsets = []
   for value in self.values:
      while value[1] >= len(values_offsets):
            return '{{{0}, 0x{mask:X}, {1}, {2}}}'.format(
      string_table.add(self.name),
   len(values_offsets), idx_table.add(values_offsets),
      else:
         def __eq__(self, other):
      return (self.name == other.name and
                     def __ne__(self, other):
            class FieldTable:
      """
   A class for collecting multiple arrays of register fields in a single big
   array that is used by indexing (to avoid relocations in the resulting binary)
   """
   def __init__(self):
      self.table = []
   self.idxs = set()
         def add(self, array):
      """
   Add an array of Field objects, and return the index of where to find
   the array in the table.
   """
   # Check if we can find the array in the table already
   for base_idx in self.name_to_idx.get(array[0].name, []):
                        for i, a in enumerate(array):
      b = self.table[base_idx + i]
   if a != b:
               base_idx = len(self.table)
            for field in array:
                        def emit(self, filp, string_table, idx_table):
      """
   Write
   static const struct si_field sid_fields_table[] = { ... };
   to filp.
   """
                     for start, end in zip(idxs, idxs[1:]):
         filp.write('\t/* %s */\n' % (start))
                  def parse_packet3(filp):
      """
   Parse PKT3 commands from the given header file.
   """
   packets = []
   for line in filp:
      if not line.startswith('#define '):
                     if line.startswith('PKT3_') and line.find('0x') != -1 and line.find('(') == -1:
               class TableWriter(object):
      def __init__(self):
      self.__strings = StringTable()
   self.__strings_offsets = IntTable('int')
         def write(self, regdb, packets, file=sys.stdout):
      def out(*args):
            out('/* This file is autogenerated by sid_tables.py from sid.h. Do not edit directly. */')
   out()
   out(CopyRight.strip())
   #ifndef SID_TABLES_H
   #define SID_TABLES_H
      struct si_field {
         unsigned name_offset;
   unsigned mask;
   unsigned num_values;
   };
      struct si_reg {
         unsigned name_offset;
   unsigned offset;
   unsigned num_fields;
   };
      struct si_packet3 {
         unsigned name_offset;
   };
   ''')
            out('static const struct si_packet3 packet3_table[] = {')
   for pkt in packets:
         out('};')
                     for regmap in regdb.register_mappings():
                           # Sorted iteration over chips for deterministic builds
   for chip in sorted(regmaps_by_chip.keys()):
                                 for regmap in regmaps:
      if hasattr(regmap, 'type_ref'):
      if not regmap.type_ref in regtypes:
         regtype = regdb.register_type(regmap.type_ref)
   fields = []
   for dbfield in regtype.fields:
      field = Field(dbfield.name, dbfield.bits)
                                 num_fields = len(regtype.fields)
                        print('\t{{{0}, {regmap.map.at}, {num_fields}, {fields_offset}}},'
                                                                        out()
         def main():
      # Parse PKT3 types
   with open(sys.argv[1], 'r') as filp:
            # Register database parse
   regdb = None
   for filename in sys.argv[2:]:
      with open(filename, 'r') as filp:
         try:
      db = RegisterDatabase.from_json(json.load(filp))
   if regdb is None:
         else:
      except json.JSONDecodeError as e:
         # The ac_debug code only distinguishes by gfx_level
            # Write it all out
   w = TableWriter()
         if __name__ == '__main__':
            # kate: space-indent on; indent-width 4; replace-tabs on;
