   /*
   * Copyright © 2015 Broadcom
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice (including the next
   * paragraph) shall be included in all copies or substantial portions of the
   * Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   */
      #include "compiler/v3d_compiler.h"
   #include "compiler/nir/nir_builder.h"
      /**
   * Walks the NIR generated by TGSI-to-NIR or GLSL-to-NIR to lower its io
   * intrinsics into something amenable to the V3D architecture.
   *
   * Most of the work is turning the VS's store_output intrinsics from working
   * on a base representing the gallium-level vec4 driver_location to an offset
   * within the VPM, and emitting the header that's read by the fixed function
   * hardware between the VS and FS.
   *
   * We also adjust the offsets on uniform loads to be in bytes, since that's
   * what we need for indirect addressing with general TMU access.
   */
      struct v3d_nir_lower_io_state {
         int pos_vpm_offset;
   int vp_vpm_offset;
   int zs_vpm_offset;
   int rcp_wc_vpm_offset;
   int psiz_vpm_offset;
            /* Geometry shader state */
   struct {
            /* VPM offset for the current vertex data output */
   nir_variable *output_offset_var;
   /* VPM offset for the current vertex header */
                        /* Size of the complete VPM output header */
   uint32_t output_header_size;
                        };
      static void
   v3d_nir_emit_ff_vpm_outputs(struct v3d_compile *c, nir_builder *b,
            static void
   v3d_nir_store_output(nir_builder *b, int base, nir_def *offset,
         {
         if (offset) {
            /* When generating the VIR instruction, the base and the offset
   * are just going to get added together with an ADD instruction
   * so we might as well do the add here at the NIR level instead
   * and let the constant folding do its magic.
   */
      } else {
                  }
      static int
   v3d_varying_slot_vpm_offset(struct v3d_compile *c, unsigned location, unsigned component)
   {
         uint32_t num_used_outputs = 0;
   struct v3d_varying_slot *used_outputs = NULL;
   switch (c->s->info.stage) {
   case MESA_SHADER_VERTEX:
            num_used_outputs = c->vs_key->num_used_outputs;
      case MESA_SHADER_GEOMETRY:
            num_used_outputs = c->gs_key->num_used_outputs;
      default:
                  for (int i = 0; i < num_used_outputs; i++) {
                     if (v3d_slot_get_slot(slot) == location &&
      v3d_slot_get_component(slot) == component) {
            }
      /* Lowers a store_output(gallium driver location) to a series of store_outputs
   * with a driver_location equal to the offset in the VPM.
   *
   * For geometry shaders we need to emit multiple vertices so the VPM offsets
   * need to be computed in the shader code based on the current vertex index.
   */
   static void
   v3d_nir_lower_vpm_output(struct v3d_compile *c, nir_builder *b,
               {
                  /* If this is a geometry shader we need to emit our outputs
      * to the current vertex offset in the VPM.
      nir_def *offset_reg =
                  int start_comp = nir_intrinsic_component(intr);
   unsigned location = nir_intrinsic_io_semantics(intr).location;
   nir_def *src = intr->src[0].ssa;
   /* Save off the components of the position for the setup of VPM inputs
      * read by fixed function HW.
      if (location == VARYING_SLOT_POS) {
            for (int i = 0; i < intr->num_components; i++) {
               /* Just psiz to the position in the FF header right now. */
   if (location == VARYING_SLOT_PSIZ &&
         state->psiz_vpm_offset != -1) {
            if (location == VARYING_SLOT_LAYER) {
                                 /* From the GLES 3.2 spec:
   *
   *    "When fragments are written to a layered framebuffer, the
   *     fragment’s layer number selects an image from the array
   *     of images at each attachment (...). If the fragment’s
   *     layer number is negative, or greater than or equal to
   *     the minimum number of layers of any attachment, the
   *     effects of the fragment on the framebuffer contents are
   *     undefined."
   *
   * This suggests we can just ignore that situation, however,
   * for V3D an out-of-bounds layer index means that the binner
   * might do out-of-bounds writes access to the tile state. The
   * simulator has an assert to catch this, so we play safe here
   * and we make sure that doesn't happen by setting gl_Layer
   * to 0 in that case (we always allocate tile state for at
   * least one layer).
   */
   nir_def *fb_layers = nir_load_fb_layers_v3d(b, 32);
   nir_def *cond = nir_ige(b, src, fb_layers);
   nir_def *layer_id =
            nir_bcsel(b, cond,
                  /* Scalarize outputs if it hasn't happened already, since we want to
      * schedule each VPM write individually.  We can skip any output
   * components not read by the FS.
      for (int i = 0; i < intr->num_components; i++) {
                                                                                             }
      static inline void
   reset_gs_header(nir_builder *b, struct v3d_nir_lower_io_state *state)
   {
         const uint8_t NEW_PRIMITIVE_OFFSET = 0;
            uint32_t vertex_data_size = state->gs.output_vertex_data_size;
            uint32_t header;
   header  = 1 << NEW_PRIMITIVE_OFFSET;
   header |= vertex_data_size << VERTEX_DATA_LENGTH_OFFSET;
   }
      static void
   v3d_nir_lower_emit_vertex(struct v3d_compile *c, nir_builder *b,
               {
                  nir_def *header = nir_load_var(b, state->gs.header_var);
   nir_def *header_offset = nir_load_var(b, state->gs.header_offset_var);
            /* Emit fixed function outputs */
            /* Emit vertex header */
            /* Update VPM offset for next vertex output data and header */
   output_offset =
                           /* Reset the New Primitive bit */
            nir_store_var(b, state->gs.output_offset_var, output_offset, 0x1);
   nir_store_var(b, state->gs.header_offset_var, header_offset, 0x1);
            }
      static void
   v3d_nir_lower_end_primitive(struct v3d_compile *c, nir_builder *b,
               {
         assert(state->gs.header_var);
   b->cursor = nir_before_instr(&instr->instr);
            }
      /* Some vertex attribute formats may require to apply a swizzle but the hardware
   * doesn't provide means to do that, so we need to apply the swizzle in the
   * vertex shader.
   *
   * This is required at least in Vulkan to support mandatory vertex attribute
   * format VK_FORMAT_B8G8R8A8_UNORM.
   */
   static void
   v3d_nir_lower_vertex_input(struct v3d_compile *c, nir_builder *b,
         {
                  if (!c->vs_key->va_swap_rb_mask)
                     if (!(c->vs_key->va_swap_rb_mask & (1 << location)))
            assert(instr->num_components == 1);
   const uint32_t comp = nir_intrinsic_component(instr);
   if (comp == 0 || comp == 2)
   }
      static void
   v3d_nir_lower_io_instr(struct v3d_compile *c, nir_builder *b,
               {
         if (instr->type != nir_instr_type_intrinsic)
                  switch (intr->intrinsic) {
   case nir_intrinsic_load_input:
                        case nir_intrinsic_store_output:
            if (c->s->info.stage == MESA_SHADER_VERTEX ||
      c->s->info.stage == MESA_SHADER_GEOMETRY) {
            case nir_intrinsic_emit_vertex:
                  case nir_intrinsic_end_primitive:
                  default:
         }
      /* Remap the output var's .driver_location.  This is purely for
   * nir_print_shader() so that store_output can map back to a variable name.
   */
   static void
   v3d_nir_lower_io_update_output_var_base(struct v3d_compile *c,
         {
         nir_foreach_shader_out_variable_safe(var, c->s) {
            if (var->data.location == VARYING_SLOT_POS &&
      state->pos_vpm_offset != -1) {
                     if (var->data.location == VARYING_SLOT_PSIZ &&
      state->psiz_vpm_offset != -1) {
                     int vpm_offset =
            v3d_varying_slot_vpm_offset(c,
      if (vpm_offset != -1) {
               } else {
            /* If we couldn't find a mapping for the var, delete
   * it so that its old .driver_location doesn't confuse
   * nir_print_shader().
   }
      static void
   v3d_nir_setup_vpm_layout_vs(struct v3d_compile *c,
         {
                  state->pos_vpm_offset = -1;
   state->vp_vpm_offset = -1;
   state->zs_vpm_offset = -1;
   state->rcp_wc_vpm_offset = -1;
            bool needs_ff_outputs = c->vs_key->base.is_last_geometry_stage;
   if (needs_ff_outputs) {
            if (c->vs_key->is_coord) {
                                       if (!c->vs_key->is_coord) {
                                             }
      static void
   v3d_nir_setup_vpm_layout_gs(struct v3d_compile *c,
         {
         /* 1 header slot for number of output vertices */
            /* 1 header slot per output vertex */
   const uint32_t num_vertices = c->s->info.gs.vertices_out;
                     /* Vertex data: here we only compute offsets into a generic vertex data
      * elements. When it is time to actually write a particular vertex to
   * the VPM, we will add the offset for that vertex into the VPM output
   * to these offsets.
   *
   * If geometry shaders are present, they are always the last shader
   * stage before rasterization, so we always emit fixed function outputs.
      vpm_offset = 0;
   if (c->gs_key->is_coord) {
               } else {
                  state->vp_vpm_offset = vpm_offset;
            if (!c->gs_key->is_coord) {
               } else {
                        /* Mesa enables OES_geometry_shader_point_size automatically with
      * OES_geometry_shader so we always need to handle point size
   * writes if present.
      if (c->gs_key->per_vertex_point_size)
                     state->gs.output_vertex_data_size =
            c->vpm_output_size =
         }
      static void
   v3d_nir_emit_ff_vpm_outputs(struct v3d_compile *c, nir_builder *b,
         {
         /* If this is a geometry shader we need to emit our fixed function
      * outputs to the current vertex offset in the VPM.
      nir_def *offset_reg =
                  for (int i = 0; i < 4; i++) {
                                 if (state->pos_vpm_offset != -1) {
            for (int i = 0; i < 4; i++) {
                     if (state->vp_vpm_offset != -1) {
            for (int i = 0; i < 2; i++) {
            nir_def *pos;
   nir_def *scale;
   pos = state->pos[i];
   if (i == 0)
         else
         pos = nir_fmul(b, pos, scale);
   pos = nir_fmul(b, pos, rcp_wc);
   /* Pre-V3D 4.3 hardware has a quirk where it expects XY
   * coordinates in .8 fixed-point format, but then it
   * will internally round it to .6 fixed-point,
   * introducing a double rounding. The double rounding
   * can cause very slight differences in triangle
   * raterization coverage that can actually be noticed by
   * some CTS tests.
   *
   * The correct fix for this as recommended by Broadcom
   * is to convert to .8 fixed-point with ffloor().
   */
                                       if (state->zs_vpm_offset != -1) {
            nir_def *z = state->pos[2];
   z = nir_fmul(b, z, nir_load_viewport_z_scale(b));
   z = nir_fmul(b, z, rcp_wc);
               if (state->rcp_wc_vpm_offset != -1) {
                        /* Store 0 to varyings requested by the FS but not stored by the
      * previous stage. This should be undefined behavior, but
   * glsl-routing seems to rely on it.
      uint32_t num_used_outputs;
   switch (c->s->info.stage) {
   case MESA_SHADER_VERTEX:
               case MESA_SHADER_GEOMETRY:
               default:
                  for (int i = 0; i < num_used_outputs; i++) {
            if (!BITSET_TEST(state->varyings_stored, i)) {
            }
      static void
   emit_gs_prolog(struct v3d_compile *c, nir_builder *b,
               {
         nir_block *first = nir_start_block(impl);
                     assert(!state->gs.output_offset_var);
   state->gs.output_offset_var =
         nir_store_var(b, state->gs.output_offset_var,
            assert(!state->gs.header_offset_var);
   state->gs.header_offset_var =
                  assert(!state->gs.header_var);
   state->gs.header_var =
         }
      static void
   emit_gs_vpm_output_header_prolog(struct v3d_compile *c, nir_builder *b,
         {
                  /* Our GS header has 1 generic header slot (at VPM offset 0) and then
      * one slot per output vertex after it. This means we don't need to
   * have a variable just to keep track of the number of vertices we
   * emitted and instead we can just compute it here from the header
   * offset variable by removing the one generic header slot that always
   * goes at the beginning of out header.
      nir_def *header_offset =
         nir_def *vertex_count =
         nir_def *header =
            nir_ior_imm(b,
               }
      bool
   v3d_nir_lower_io(nir_shader *s, struct v3d_compile *c)
   {
                  /* Set up the layout of the VPM outputs. */
   switch (s->info.stage) {
   case MESA_SHADER_VERTEX:
               case MESA_SHADER_GEOMETRY:
               case MESA_SHADER_FRAGMENT:
   case MESA_SHADER_COMPUTE:
         default:
                  nir_foreach_function_impl(impl, s) {
                                    nir_foreach_block(block, impl) {
                              nir_block *last = nir_impl_last_block(impl);
   b.cursor = nir_after_block(last);
   if (s->info.stage == MESA_SHADER_VERTEX) {
                              nir_metadata_preserve(impl,
               if (s->info.stage == MESA_SHADER_VERTEX ||
         s->info.stage == MESA_SHADER_GEOMETRY) {
            /* It is really unlikely that we don't get progress here, and fully
      * filtering when not would make code more complex, but we are still
   * interested on getting this lowering going through NIR_PASS
      }
