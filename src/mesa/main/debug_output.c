   /*
   * Mesa 3-D graphics library
   *
   * Copyright (C) 1999-2016  Brian Paul, et al   All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included
   * in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   */
         #include <stdarg.h>
   #include <stdio.h>
   #include "context.h"
   #include "debug_output.h"
   #include "enums.h"
      #include "hash.h"
   #include "mtypes.h"
   #include "version.h"
   #include "util/hash_table.h"
   #include "util/list.h"
   #include "util/u_memory.h"
   #include "api_exec_decl.h"
      #include "pipe/p_context.h"
      static GLuint PrevDynamicID = 0;
         /**
   * A namespace element.
   */
   struct gl_debug_element
   {
               GLuint ID;
   /* at which severity levels (mesa_debug_severity) is the message enabled */
      };
         struct gl_debug_namespace
   {
      struct list_head Elements;
      };
         struct gl_debug_group {
         };
         /**
   * An error, warning, or other piece of debug information for an application
   * to consume via GL_ARB_debug_output/GL_KHR_debug.
   */
   struct gl_debug_message
   {
      enum mesa_debug_source source;
   enum mesa_debug_type type;
   GLuint id;
   enum mesa_debug_severity severity;
   /* length as given by the user - if message was explicitly null terminated,
   * length can be negative */
   GLsizei length;
      };
         /**
   * Debug message log.  It works like a ring buffer.
   */
   struct gl_debug_log {
      struct gl_debug_message Messages[MAX_DEBUG_LOGGED_MESSAGES];
   GLint NextMessage;
      };
         struct gl_debug_state
   {
      GLDEBUGPROC Callback;
   const void *CallbackData;
   GLboolean SyncOutput;
   GLboolean DebugOutput;
            struct gl_debug_group *Groups[MAX_DEBUG_GROUP_STACK_DEPTH];
   struct gl_debug_message GroupMessages[MAX_DEBUG_GROUP_STACK_DEPTH];
               };
         static char out_of_memory[] = "Debugging error: out of memory";
      static const GLenum debug_source_enums[] = {
      GL_DEBUG_SOURCE_API,
   GL_DEBUG_SOURCE_WINDOW_SYSTEM,
   GL_DEBUG_SOURCE_SHADER_COMPILER,
   GL_DEBUG_SOURCE_THIRD_PARTY,
   GL_DEBUG_SOURCE_APPLICATION,
      };
      static const GLenum debug_type_enums[] = {
      GL_DEBUG_TYPE_ERROR,
   GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR,
   GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR,
   GL_DEBUG_TYPE_PORTABILITY,
   GL_DEBUG_TYPE_PERFORMANCE,
   GL_DEBUG_TYPE_OTHER,
   GL_DEBUG_TYPE_MARKER,
   GL_DEBUG_TYPE_PUSH_GROUP,
      };
      static const GLenum debug_severity_enums[] = {
      GL_DEBUG_SEVERITY_LOW,
   GL_DEBUG_SEVERITY_MEDIUM,
   GL_DEBUG_SEVERITY_HIGH,
      };
         static enum mesa_debug_source
   gl_enum_to_debug_source(GLenum e)
   {
               for (i = 0; i < ARRAY_SIZE(debug_source_enums); i++) {
      if (debug_source_enums[i] == e)
      }
      }
      static enum mesa_debug_type
   gl_enum_to_debug_type(GLenum e)
   {
               for (i = 0; i < ARRAY_SIZE(debug_type_enums); i++) {
      if (debug_type_enums[i] == e)
      }
      }
      static enum mesa_debug_severity
   gl_enum_to_debug_severity(GLenum e)
   {
               for (i = 0; i < ARRAY_SIZE(debug_severity_enums); i++) {
      if (debug_severity_enums[i] == e)
      }
      }
         /**
   * Handles generating a GL_ARB_debug_output message ID generated by the GL or
   * GLSL compiler.
   *
   * The GL API has this "ID" mechanism, where the intention is to allow a
   * client to filter in/out messages based on source, type, and ID.  Of course,
   * building a giant enum list of all debug output messages that Mesa might
   * generate is ridiculous, so instead we have our caller pass us a pointer to
   * static storage where the ID should get stored.  This ID will be shared
   * across all contexts for that message (which seems like a desirable
   * property, even if it's not expected by the spec), but note that it won't be
   * the same between executions if messages aren't generated in the same order.
   */
   void
   _mesa_debug_get_id(GLuint *id)
   {
      if (!(*id)) {
      /* Don't update *id if we raced with some other thread. */
         }
      static void
   debug_message_clear(struct gl_debug_message *msg)
   {
      if (msg->message != (char*)out_of_memory)
         msg->message = NULL;
      }
      static void
   debug_message_store(struct gl_debug_message *msg,
                     enum mesa_debug_source source,
   {
                        if (length < 0)
            msg->message = malloc(length+1);
   if (msg->message) {
      (void) strncpy(msg->message, buf, (size_t)length);
            msg->length = len;
   msg->source = source;
   msg->type = type;
   msg->id = id;
      } else {
      static GLuint oom_msg_id = 0;
            /* malloc failed! */
   msg->message = out_of_memory;
   msg->length = -1;
   msg->source = MESA_DEBUG_SOURCE_OTHER;
   msg->type = MESA_DEBUG_TYPE_ERROR;
   msg->id = oom_msg_id;
         }
      static void
   debug_namespace_init(struct gl_debug_namespace *ns)
   {
               /* Enable all the messages with severity HIGH or MEDIUM by default */
   ns->DefaultState = (1 << MESA_DEBUG_SEVERITY_MEDIUM ) |
            }
      static void
   debug_namespace_clear(struct gl_debug_namespace *ns)
   {
      list_for_each_entry_safe(struct gl_debug_element, elem, &ns->Elements, link)
      }
      static bool
   debug_namespace_copy(struct gl_debug_namespace *dst,
         {
               list_inithead(&dst->Elements);
   list_for_each_entry(struct gl_debug_element, elem, &src->Elements, link) {
               copy = malloc(sizeof(*copy));
   if (!copy) {
      debug_namespace_clear(dst);
               copy->ID = elem->ID;
   copy->State = elem->State;
                  }
      /**
   * Set the state of \p id in the namespace.
   */
   static bool
   debug_namespace_set(struct gl_debug_namespace *ns,
         {
      const uint32_t state = (enabled) ?
                  /* find the element */
   list_for_each_entry(struct gl_debug_element, tmp, &ns->Elements, link) {
      if (tmp->ID == id) {
      elem = tmp;
                  /* we do not need the element if it has the default state */
   if (ns->DefaultState == state) {
      if (elem) {
      list_del(&elem->link);
      }
               if (!elem) {
      elem = malloc(sizeof(*elem));
   if (!elem)
            elem->ID = id;
                           }
      /**
   * Set the default state of the namespace for \p severity.  When \p severity
   * is MESA_DEBUG_SEVERITY_COUNT, the default values for all severities are
   * updated.
   */
   static void
   debug_namespace_set_all(struct gl_debug_namespace *ns,
               {
               /* set all elements to the same state */
   if (severity == MESA_DEBUG_SEVERITY_COUNT) {
      ns->DefaultState = (enabled) ? ((1 << severity) - 1) : 0;
   debug_namespace_clear(ns);
   list_inithead(&ns->Elements);
               mask = 1 << severity;
                     list_for_each_entry_safe(struct gl_debug_element, elem, &ns->Elements,
            elem->State = (elem->State & ~mask) | val;
   if (elem->State == ns->DefaultState) {
      list_del(&elem->link);
            }
      /**
   * Get the state of \p id in the namespace.
   */
   static bool
   debug_namespace_get(const struct gl_debug_namespace *ns, GLuint id,
         {
               state = ns->DefaultState;
   list_for_each_entry(struct gl_debug_element, elem, &ns->Elements, link) {
      if (elem->ID == id) {
      state = elem->State;
                     }
      /**
   * Allocate and initialize context debug state.
   */
   static struct gl_debug_state *
   debug_create(void)
   {
      struct gl_debug_state *debug;
            debug = CALLOC_STRUCT(gl_debug_state);
   if (!debug)
            debug->Groups[0] = malloc(sizeof(*debug->Groups[0]));
   if (!debug->Groups[0]) {
      free(debug);
               /* Initialize state for filtering known debug messages. */
   for (s = 0; s < MESA_DEBUG_SOURCE_COUNT; s++) {
      for (t = 0; t < MESA_DEBUG_TYPE_COUNT; t++)
                  }
      /**
   * Return true if the top debug group points to the group below it.
   */
   static bool
   debug_is_group_read_only(const struct gl_debug_state *debug)
   {
      const GLint gstack = debug->CurrentGroup;
      }
      /**
   * Make the top debug group writable.
   */
   static bool
   debug_make_group_writable(struct gl_debug_state *debug)
   {
      const GLint gstack = debug->CurrentGroup;
   const struct gl_debug_group *src = debug->Groups[gstack];
   struct gl_debug_group *dst;
            if (!debug_is_group_read_only(debug))
            dst = malloc(sizeof(*dst));
   if (!dst)
            for (s = 0; s < MESA_DEBUG_SOURCE_COUNT; s++) {
      for (t = 0; t < MESA_DEBUG_TYPE_COUNT; t++) {
      if (!debug_namespace_copy(&dst->Namespaces[s][t],
            /* error path! */
   for (t = t - 1; t >= 0; t--)
         for (s = s - 1; s >= 0; s--) {
      for (t = 0; t < MESA_DEBUG_TYPE_COUNT; t++)
      }
   free(dst);
                                 }
      /**
   * Free the top debug group.
   */
   static void
   debug_clear_group(struct gl_debug_state *debug)
   {
               if (!debug_is_group_read_only(debug)) {
      struct gl_debug_group *grp = debug->Groups[gstack];
            for (s = 0; s < MESA_DEBUG_SOURCE_COUNT; s++) {
      for (t = 0; t < MESA_DEBUG_TYPE_COUNT; t++)
                              }
      /**
   * Delete the oldest debug messages out of the log.
   */
   static void
   debug_delete_messages(struct gl_debug_state *debug, int count)
   {
               if (count > log->NumMessages)
            while (count--) {
                        log->NumMessages--;
   log->NextMessage++;
         }
      /**
   * Loop through debug group stack tearing down states for
   * filtering debug messages.  Then free debug output state.
   */
   static void
   debug_destroy(struct gl_debug_state *debug)
   {
      while (debug->CurrentGroup > 0) {
      debug_clear_group(debug);
               debug_clear_group(debug);
   debug_delete_messages(debug, debug->Log.NumMessages);
      }
      /**
   * Sets the state of the given message source/type/ID tuple.
   */
   static void
   debug_set_message_enable(struct gl_debug_state *debug,
                     {
      const GLint gstack = debug->CurrentGroup;
            debug_make_group_writable(debug);
               }
      /*
   * Set the state of all message IDs found in the given intersection of
   * 'source', 'type', and 'severity'.  The _COUNT enum can be used for
   * GL_DONT_CARE (include all messages in the class).
   *
   * This requires both setting the state of all previously seen message
   * IDs in the hash table, and setting the default state for all
   * applicable combinations of source/type/severity, so that all the
   * yet-unknown message IDs that may be used in the future will be
   * impacted as if they were already known.
   */
   static void
   debug_set_message_enable_all(struct gl_debug_state *debug,
                           {
      const GLint gstack = debug->CurrentGroup;
            if (source == MESA_DEBUG_SOURCE_COUNT) {
      source = 0;
      } else {
                  if (type == MESA_DEBUG_TYPE_COUNT) {
      type = 0;
      } else {
                           for (s = source; s < smax; s++) {
      for (t = type; t < tmax; t++) {
      struct gl_debug_namespace *nspace =
                  }
      /**
   * Returns if the given message source/type/ID tuple is enabled.
   */
   bool
   _mesa_debug_is_message_enabled(const struct gl_debug_state *debug,
                           {
      const GLint gstack = debug->CurrentGroup;
   struct gl_debug_group *grp = debug->Groups[gstack];
            if (!debug->DebugOutput)
               }
      /**
   * 'buf' is not necessarily a null-terminated string. When logging, copy
   * 'len' characters from it, store them in a new, null-terminated string,
   * and remember the number of bytes used by that string, *including*
   * the null terminator this time.
   */
   static void
   debug_log_message(struct gl_debug_state *debug,
                     enum mesa_debug_source source,
   {
      struct gl_debug_log *log = &debug->Log;
   GLint nextEmpty;
            if (debug->LogToStderr) {
                           if (log->NumMessages == MAX_DEBUG_LOGGED_MESSAGES)
            nextEmpty = (log->NextMessage + log->NumMessages)
                  debug_message_store(emptySlot, source, type,
               }
      /**
   * Return the oldest debug message out of the log.
   */
   static const struct gl_debug_message *
   debug_fetch_message(const struct gl_debug_state *debug)
   {
                  }
      static struct gl_debug_message *
   debug_get_group_message(struct gl_debug_state *debug)
   {
         }
      static void
   debug_push_group(struct gl_debug_state *debug)
   {
               /* just point to the previous stack */
   debug->Groups[gstack + 1] = debug->Groups[gstack];
      }
      static void
   debug_pop_group(struct gl_debug_state *debug)
   {
      debug_clear_group(debug);
      }
         /**
   * Installed as util_debug_callback when GL_DEBUG_OUTPUT is enabled.
   */
   static void
   _debug_message(void *data,
                  unsigned *id,
      {
      struct gl_context *ctx = data;
   enum mesa_debug_source source;
   enum mesa_debug_type type;
            switch (ptype) {
   case UTIL_DEBUG_TYPE_OUT_OF_MEMORY:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_ERROR;
   severity = MESA_DEBUG_SEVERITY_MEDIUM;
      case UTIL_DEBUG_TYPE_ERROR:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_ERROR;
   severity = MESA_DEBUG_SEVERITY_MEDIUM;
      case UTIL_DEBUG_TYPE_SHADER_INFO:
      source = MESA_DEBUG_SOURCE_SHADER_COMPILER;
   type = MESA_DEBUG_TYPE_OTHER;
   severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
      case UTIL_DEBUG_TYPE_PERF_INFO:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_PERFORMANCE;
   severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
      case UTIL_DEBUG_TYPE_INFO:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_OTHER;
   severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
      case UTIL_DEBUG_TYPE_FALLBACK:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_PERFORMANCE;
   severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
      case UTIL_DEBUG_TYPE_CONFORMANCE:
      source = MESA_DEBUG_SOURCE_API;
   type = MESA_DEBUG_TYPE_OTHER;
   severity = MESA_DEBUG_SEVERITY_NOTIFICATION;
      default:
         }
      }
      void
   _mesa_update_debug_callback(struct gl_context *ctx)
   {
               if (!pipe->set_debug_callback)
            if (_mesa_get_debug_state_int(ctx, GL_DEBUG_OUTPUT)) {
      struct util_debug_callback cb;
   memset(&cb, 0, sizeof(cb));
   cb.async = !_mesa_get_debug_state_int(ctx, GL_DEBUG_OUTPUT_SYNCHRONOUS);
   cb.debug_message = _debug_message;
   cb.data = ctx;
      } else {
            }
      /**
   * Lock and return debug state for the context.  The debug state will be
   * allocated and initialized upon the first call.  When NULL is returned, the
   * debug state is not locked.
   */
   static struct gl_debug_state *
   _mesa_lock_debug_state(struct gl_context *ctx)
   {
               if (!ctx->Debug) {
      ctx->Debug = debug_create();
   if (!ctx->Debug) {
                     /*
   * This function may be called from other threads.  When that is the
   * case, we cannot record this OOM error.
   */
                                    }
      static void
   _mesa_unlock_debug_state(struct gl_context *ctx)
   {
         }
      /**
   * Set the integer debug state specified by \p pname.  This can be called from
   * _mesa_set_enable for example.
   */
   bool
   _mesa_set_debug_state_int(struct gl_context *ctx, GLenum pname, GLint val)
   {
               if (!debug)
            switch (pname) {
   case GL_DEBUG_OUTPUT:
      debug->DebugOutput = (val != 0);
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
      debug->SyncOutput = (val != 0);
      default:
      assert(!"unknown debug output param");
                           }
      /**
   * Query the integer debug state specified by \p pname.  This can be called
   * _mesa_GetIntegerv for example.
   */
   GLint
   _mesa_get_debug_state_int(struct gl_context *ctx, GLenum pname)
   {
               struct gl_debug_state *debug = _mesa_lock_debug_state(ctx);
   if (!debug)
            switch (pname) {
   case GL_DEBUG_OUTPUT:
      val = debug->DebugOutput;
      case GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB:
      val = debug->SyncOutput;
      case GL_DEBUG_LOGGED_MESSAGES:
      val = debug->Log.NumMessages;
      case GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH:
      val = (debug->Log.NumMessages) ?
            case GL_DEBUG_GROUP_STACK_DEPTH:
      val = debug->CurrentGroup + 1;
      default:
      assert(!"unknown debug output param");
   val = 0;
                           }
      /**
   * Query the pointer debug state specified by \p pname.  This can be called
   * _mesa_GetPointerv for example.
   */
   void *
   _mesa_get_debug_state_ptr(struct gl_context *ctx, GLenum pname)
   {
      void *val;
            if (!debug)
            switch (pname) {
   case GL_DEBUG_CALLBACK_FUNCTION_ARB:
      val = (void *) debug->Callback;
      case GL_DEBUG_CALLBACK_USER_PARAM_ARB:
      val = (void *) debug->CallbackData;
      default:
      assert(!"unknown debug output param");
   val = NULL;
                           }
      /**
   * Insert a debug message.  The mutex is assumed to be locked, and will be
   * unlocked by this call.
   */
   static void
   log_msg_locked_and_unlock(struct gl_context *ctx,
                           {
               if (!_mesa_debug_is_message_enabled(debug, source, type, id, severity)) {
      _mesa_unlock_debug_state(ctx);
               if (ctx->Debug->Callback) {
      /* Call the user's callback function */
   GLenum gl_source = debug_source_enums[source];
   GLenum gl_type = debug_type_enums[type];
   GLenum gl_severity = debug_severity_enums[severity];
   GLDEBUGPROC callback = ctx->Debug->Callback;
            /*
   * When ctx->Debug->SyncOutput is GL_FALSE, the client is prepared for
   * unsynchronous calls.  When it is GL_TRUE, we will not spawn threads.
   * In either case, we can call the callback unlocked.
   */
   _mesa_unlock_debug_state(ctx);
      }
   else {
      /* add debug message to queue */
   debug_log_message(ctx->Debug, source, type, id, severity, len, buf);
         }
      /**
   * Log a client or driver debug message.
   */
   void
   _mesa_log_msg(struct gl_context *ctx, enum mesa_debug_source source,
               {
               if (!debug)
               }
         /**
   * Verify that source, type, and severity are valid enums.
   *
   * The 'caller' param is used for handling values available
   * only in glDebugMessageInsert or glDebugMessageControl
   */
   static GLboolean
   validate_params(struct gl_context *ctx, unsigned caller,
               {
   #define INSERT 1
   #define CONTROL 2
      switch(source) {
   case GL_DEBUG_SOURCE_APPLICATION_ARB:
   case GL_DEBUG_SOURCE_THIRD_PARTY_ARB:
         case GL_DEBUG_SOURCE_API_ARB:
   case GL_DEBUG_SOURCE_SHADER_COMPILER_ARB:
   case GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB:
   case GL_DEBUG_SOURCE_OTHER_ARB:
      if (caller != INSERT)
         else
      case GL_DONT_CARE:
      if (caller == CONTROL)
         else
      default:
                  switch(type) {
   case GL_DEBUG_TYPE_ERROR_ARB:
   case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB:
   case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB:
   case GL_DEBUG_TYPE_PERFORMANCE_ARB:
   case GL_DEBUG_TYPE_PORTABILITY_ARB:
   case GL_DEBUG_TYPE_OTHER_ARB:
   case GL_DEBUG_TYPE_MARKER:
   case GL_DEBUG_TYPE_PUSH_GROUP:
   case GL_DEBUG_TYPE_POP_GROUP:
         case GL_DONT_CARE:
      if (caller == CONTROL)
         else
      default:
                  switch(severity) {
   case GL_DEBUG_SEVERITY_HIGH_ARB:
   case GL_DEBUG_SEVERITY_MEDIUM_ARB:
   case GL_DEBUG_SEVERITY_LOW_ARB:
   case GL_DEBUG_SEVERITY_NOTIFICATION:
         case GL_DONT_CARE:
      if (caller == CONTROL)
         else
      default:
         }
         error:
      _mesa_error(ctx, GL_INVALID_ENUM, "bad values passed to %s"
                     }
         static GLboolean
   validate_length(struct gl_context *ctx, const char *callerstr, GLsizei length,
         {
         if (length < 0) {
               if (len >= MAX_DEBUG_MESSAGE_LENGTH) {
      _mesa_error(ctx, GL_INVALID_VALUE,
            "%s(null terminated string length=%d, is not less than "
                     if (length >= MAX_DEBUG_MESSAGE_LENGTH) {
      _mesa_error(ctx, GL_INVALID_VALUE,
            "%s(length=%d, which is not less than "
                     }
         void GLAPIENTRY
   _mesa_DebugMessageInsert(GLenum source, GLenum type, GLuint id,
               {
      GET_CURRENT_CONTEXT(ctx);
            if (_mesa_is_desktop_gl(ctx))
         else
            if (!validate_params(ctx, INSERT, callerstr, source, type, severity))
            if (!validate_length(ctx, callerstr, length, buf))
            /* if length not specified, string will be null terminated: */
   if (length < 0)
            _mesa_log_msg(ctx, gl_enum_to_debug_source(source),
                        if (type == GL_DEBUG_TYPE_MARKER && ctx->has_string_marker) {
            }
         GLuint GLAPIENTRY
   _mesa_GetDebugMessageLog(GLuint count, GLsizei logSize, GLenum *sources,
               {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_debug_state *debug;
   const char *callerstr;
            if (_mesa_is_desktop_gl(ctx))
         else
            if (!messageLog)
            if (logSize < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           debug = _mesa_lock_debug_state(ctx);
   if (!debug)
            for (ret = 0; ret < count; ret++) {
      const struct gl_debug_message *msg = debug_fetch_message(debug);
            if (!msg)
            len = msg->length;
   if (len < 0)
            if (logSize < len+1 && messageLog != NULL)
            if (messageLog) {
                     messageLog += len+1;
               if (lengths)
         if (severities)
         if (sources)
         if (types)
         if (ids)
                                    }
         void GLAPIENTRY
   _mesa_DebugMessageControl(GLenum gl_source, GLenum gl_type,
               {
      GET_CURRENT_CONTEXT(ctx);
   enum mesa_debug_source source = gl_enum_to_debug_source(gl_source);
   enum mesa_debug_type type = gl_enum_to_debug_type(gl_type);
   enum mesa_debug_severity severity = gl_enum_to_debug_severity(gl_severity);
   const char *callerstr;
            if (_mesa_is_desktop_gl(ctx))
         else
            if (count < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           if (!validate_params(ctx, CONTROL, callerstr, gl_source, gl_type,
                  if (count && (gl_severity != GL_DONT_CARE || gl_type == GL_DONT_CARE
            _mesa_error(ctx, GL_INVALID_OPERATION,
            " GL_DONT_CARE, and source and type must not be GL_DONT_CARE.",
                  debug = _mesa_lock_debug_state(ctx);
   if (!debug)
            if (count) {
      GLsizei i;
   for (i = 0; i < count; i++)
      }
   else {
                     }
         void GLAPIENTRY
   _mesa_DebugMessageCallback(GLDEBUGPROC callback, const void *userParam)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_debug_state *debug = _mesa_lock_debug_state(ctx);
   if (debug) {
      debug->Callback = callback;
   debug->CallbackData = userParam;
         }
         void GLAPIENTRY
   _mesa_PushDebugGroup(GLenum source, GLuint id, GLsizei length,
         {
      GET_CURRENT_CONTEXT(ctx);
   const char *callerstr;
   struct gl_debug_state *debug;
            if (_mesa_is_desktop_gl(ctx))
         else
            switch(source) {
   case GL_DEBUG_SOURCE_APPLICATION:
   case GL_DEBUG_SOURCE_THIRD_PARTY:
         default:
      _mesa_error(ctx, GL_INVALID_ENUM, "bad value passed to %s"
                     if (!validate_length(ctx, callerstr, length, message))
            if (length < 0)
            debug = _mesa_lock_debug_state(ctx);
   if (!debug)
            if (debug->CurrentGroup >= MAX_DEBUG_GROUP_STACK_DEPTH-1) {
      _mesa_unlock_debug_state(ctx);
   _mesa_error(ctx, GL_STACK_OVERFLOW, "%s", callerstr);
               /* pop reuses the message details from push so we store this */
   emptySlot = debug_get_group_message(debug);
   debug_message_store(emptySlot,
                     gl_enum_to_debug_source(source),
                     log_msg_locked_and_unlock(ctx,
         gl_enum_to_debug_source(source),
   MESA_DEBUG_TYPE_PUSH_GROUP, id,
      }
         void GLAPIENTRY
   _mesa_PopDebugGroup(void)
   {
      GET_CURRENT_CONTEXT(ctx);
   const char *callerstr;
   struct gl_debug_state *debug;
            if (_mesa_is_desktop_gl(ctx))
         else
            debug = _mesa_lock_debug_state(ctx);
   if (!debug)
            if (debug->CurrentGroup <= 0) {
      _mesa_unlock_debug_state(ctx);
   _mesa_error(ctx, GL_STACK_UNDERFLOW, "%s", callerstr);
                        /* make a shallow copy */
   gdmessage = debug_get_group_message(debug);
   msg = *gdmessage;
   gdmessage->message = NULL;
            log_msg_locked_and_unlock(ctx,
         msg.source,
   gl_enum_to_debug_type(GL_DEBUG_TYPE_POP_GROUP),
   msg.id,
               }
         void
   _mesa_init_debug_output(struct gl_context *ctx)
   {
               if (MESA_DEBUG_FLAGS & DEBUG_CONTEXT) {
      /* If the MESA_DEBUG env is set to "context", we'll turn on the
   * GL_CONTEXT_FLAG_DEBUG_BIT context flag and log debug output
   * messages to stderr (or whatever MESA_LOG_FILE points at).
   */
   struct gl_debug_state *debug = _mesa_lock_debug_state(ctx);
   if (!debug) {
         }
   debug->DebugOutput = GL_TRUE;
   debug->LogToStderr = GL_TRUE;
   ctx->Const.ContextFlags |= GL_CONTEXT_FLAG_DEBUG_BIT;
         }
         void
   _mesa_destroy_debug_output(struct gl_context *ctx)
   {
      if (ctx->Debug) {
      debug_destroy(ctx->Debug);
   /* set to NULL just in case it is used before context is completely gone. */
                  }
      void GLAPIENTRY
   _mesa_StringMarkerGREMEDY(GLsizei len, const GLvoid *string)
   {
      GET_CURRENT_CONTEXT(ctx);
   if (ctx->Extensions.GREMEDY_string_marker) {
      /* if length not specified, string will be null terminated: */
   if (len <= 0)
            } else {
            }
