   /**
   * \file atifragshader.c
   * \author David Airlie
   * Copyright (C) 2004  David Airlie   All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included
   * in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * DAVID AIRLIE BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
   * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   */
      #include "util/glheader.h"
   #include "main/context.h"
   #include "main/hash.h"
      #include "main/macros.h"
   #include "main/enums.h"
   #include "main/mtypes.h"
   #include "main/atifragshader.h"
   #include "program/program.h"
   #include "program/prog_instruction.h"
   #include "util/u_memory.h"
   #include "api_exec_decl.h"
      #include "state_tracker/st_program.h"
      #define MESA_DEBUG_ATI_FS 0
      static struct ati_fragment_shader DummyShader;
         /**
   * Allocate and initialize a new ATI fragment shader object.
   */
   struct ati_fragment_shader *
   _mesa_new_ati_fragment_shader(struct gl_context *ctx, GLuint id)
   {
      struct ati_fragment_shader *s = CALLOC_STRUCT(ati_fragment_shader);
   (void) ctx;
   if (s) {
      s->Id = id;
      }
      }
      static struct gl_program *
   new_ati_fs(struct gl_context *ctx, struct ati_fragment_shader *curProg)
   {
      struct gl_program *prog = rzalloc(NULL, struct gl_program);
   if (!prog)
            _mesa_init_gl_program(prog, MESA_SHADER_FRAGMENT, curProg->Id, true);
   prog->ati_fs = curProg;
      }
      /**
   * Delete the given ati fragment shader
   */
   void
   _mesa_delete_ati_fragment_shader(struct gl_context *ctx, struct ati_fragment_shader *s)
   {
               if (s == &DummyShader)
            for (i = 0; i < MAX_NUM_PASSES_ATI; i++) {
      free(s->Instructions[i]);
      }
   _mesa_reference_program(ctx, &s->Program, NULL);
      }
         static void match_pair_inst(struct ati_fragment_shader *curProg, GLuint optype)
   {
      if (optype == curProg->last_optype) {
            }
      #if MESA_DEBUG_ATI_FS
   static char *
   create_dst_mod_str(GLuint mod)
   {
               memset(ret_str, 0, 1024);
   if (mod & GL_2X_BIT_ATI)
            if (mod & GL_4X_BIT_ATI)
            if (mod & GL_8X_BIT_ATI)
         if (mod & GL_HALF_BIT_ATI)
         if (mod & GL_QUARTER_BIT_ATI)
         if (mod & GL_EIGHTH_BIT_ATI)
            if (mod & GL_SATURATE_BIT_ATI)
            if (strlen(ret_str) == 0)
            }
      static char *atifs_ops[] = {"ColorFragmentOp1ATI", "ColorFragmentOp2ATI", "ColorFragmentOp3ATI",
            static void debug_op(GLint optype, GLuint arg_count, GLenum op, GLuint dst,
         GLuint dstMask, GLuint dstMod, GLuint arg1,
   GLuint arg1Rep, GLuint arg1Mod, GLuint arg2,
   GLuint arg2Rep, GLuint arg2Mod, GLuint arg3,
   {
   char *op_name;
      op_name = atifs_ops[(arg_count-1)+(optype?3:0)];
      fprintf(stderr, "%s(%s, %s", op_name, _mesa_enum_to_string(op),
         if (optype == ATI_FRAGMENT_SHADER_COLOR_OP)
            fprintf(stderr, ", %s", create_dst_mod_str(dstMod));
      fprintf(stderr, ", %s, %s, %d", _mesa_enum_to_string(arg1),
         if (arg_count>1)
      fprintf(stderr, ", %s, %s, %d", _mesa_enum_to_string(arg2),
      if (arg_count>2)
      fprintf(stderr, ", %s, %s, %d", _mesa_enum_to_string(arg3),
         fprintf(stderr,")\n");
      }
   #endif
      static int
   check_arith_arg(GLuint optype, GLuint arg, GLuint argRep)
   {
               if (((arg < GL_CON_0_ATI) || (arg > GL_CON_7_ATI)) &&
      ((arg < GL_REG_0_ATI) || (arg > GL_REG_5_ATI)) &&
   (arg != GL_ZERO) && (arg != GL_ONE) &&
   (arg != GL_PRIMARY_COLOR_ARB) && (arg != GL_SECONDARY_INTERPOLATOR_ATI)) {
   _mesa_error(ctx, GL_INVALID_ENUM, "C/AFragmentOpATI(arg)");
      }
   /* The ATI_fragment_shader spec says:
   *
   *        The error INVALID_OPERATION is generated by
   *        ColorFragmentOp[1..3]ATI if <argN> is SECONDARY_INTERPOLATOR_ATI
   *        and <argNRep> is ALPHA, or by AlphaFragmentOp[1..3]ATI if <argN>
   *        is SECONDARY_INTERPOLATOR_ATI and <argNRep> is ALPHA or NONE, ...
   */
   if (arg == GL_SECONDARY_INTERPOLATOR_ATI) {
      if (optype == ATI_FRAGMENT_SHADER_COLOR_OP && argRep == GL_ALPHA) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "CFragmentOpATI(sec_interp)");
      } else if (optype == ATI_FRAGMENT_SHADER_ALPHA_OP &&
            _mesa_error(ctx, GL_INVALID_OPERATION, "AFragmentOpATI(sec_interp)");
         }
      }
      static GLboolean
   check_arg_color(GLubyte pass, GLuint arg)
   {
      if (pass == 1 && (arg == GL_PRIMARY_COLOR_ARB || arg == GL_SECONDARY_INTERPOLATOR_ATI))
            }
      GLuint GLAPIENTRY
   _mesa_GenFragmentShadersATI(GLuint range)
   {
      GLuint first;
   GLuint i;
            if (range == 0) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGenFragmentShadersATI(range)");
               if (ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glGenFragmentShadersATI(insideShader)");
                        first = _mesa_HashFindFreeKeyBlock(ctx->Shared->ATIShaders, range);
   for (i = 0; i < range; i++) {
                              }
      void GLAPIENTRY
   _mesa_BindFragmentShaderATI(GLuint id)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct ati_fragment_shader *curProg = ctx->ATIFragmentShader.Current;
            if (ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBindFragmentShaderATI(insideShader)");
                        if (curProg->Id == id) {
                  /* unbind current */
   if (curProg->Id != 0) {
      curProg->RefCount--;
   _mesa_HashRemove(ctx->Shared->ATIShaders, id);
                     /* find new shader */
   if (id == 0) {
         }
   else {
      bool isGenName;
   newProg = (struct ati_fragment_shader *)
         isGenName = newProg != NULL;
   /* allocate a new program now */
   newProg = _mesa_new_ati_fragment_shader(ctx, id);
   if (!newProg) {
      _mesa_error(ctx, GL_OUT_OF_MEMORY, "glBindFragmentShaderATI");
      }
   _mesa_HashInsert(ctx->Shared->ATIShaders, id, newProg, isGenName);
                        /* do actual bind */
            assert(ctx->ATIFragmentShader.Current);
   if (newProg)
      }
      void GLAPIENTRY
   _mesa_DeleteFragmentShaderATI(GLuint id)
   {
               if (ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glDeleteFragmentShaderATI(insideShader)");
               if (id != 0) {
      _mesa_HashLookup(ctx->Shared->ATIShaders, id);
         _mesa_HashRemove(ctx->Shared->ATIShaders, id);
         }
   if (ctx->ATIFragmentShader.Current &&
         ctx->ATIFragmentShader.Current->Id == id) {
         }
                  /* The ID is immediately available for re-use now */
   _mesa_HashRemove(ctx->Shared->ATIShaders, id);
   prog->RefCount--;
   if (prog->RefCount <= 0) {
         }
               }
         void GLAPIENTRY
   _mesa_BeginFragmentShaderATI(void)
   {
      GLint i;
            if (ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glBeginFragmentShaderATI(insideShader)");
                        /* if the shader was already defined free instructions and get new ones
         /* no idea if it's allowed to redefine a shader */
   for (i = 0; i < MAX_NUM_PASSES_ATI; i++) {
         free(ctx->ATIFragmentShader.Current->Instructions[i]);
                     /* malloc the instructions here - not sure if the best place but its
         for (i = 0; i < MAX_NUM_PASSES_ATI; i++) {
      calloc(sizeof(struct atifs_instruction),
               calloc(sizeof(struct atifs_setupinst),
                  /* can't rely on calloc for initialization as it's possible to redefine a shader (?) */
      ctx->ATIFragmentShader.Current->LocalConstDef = 0;
   ctx->ATIFragmentShader.Current->numArithInstr[0] = 0;
   ctx->ATIFragmentShader.Current->numArithInstr[1] = 0;
   ctx->ATIFragmentShader.Current->regsAssigned[0] = 0;
   ctx->ATIFragmentShader.Current->regsAssigned[1] = 0;
   ctx->ATIFragmentShader.Current->NumPasses = 0;
   ctx->ATIFragmentShader.Current->cur_pass = 0;
   ctx->ATIFragmentShader.Current->last_optype = 0;
   ctx->ATIFragmentShader.Current->interpinp1 = GL_FALSE;
   ctx->ATIFragmentShader.Current->isValid = GL_FALSE;
   ctx->ATIFragmentShader.Current->swizzlerq = 0;
      #if MESA_DEBUG_ATI_FS
         #endif
   }
      void GLAPIENTRY
   _mesa_EndFragmentShaderATI(void)
   {
      GET_CURRENT_CONTEXT(ctx);
      #if MESA_DEBUG_ATI_FS
         #endif
         if (!ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glEndFragmentShaderATI(outsideShader)");
      }
   if (curProg->interpinp1 && (ctx->ATIFragmentShader.Current->cur_pass > 1)) {
         /* according to spec, DON'T return here */
            match_pair_inst(curProg, 0);
   ctx->ATIFragmentShader.Compiling = 0;
   ctx->ATIFragmentShader.Current->isValid = GL_TRUE;
   if ((ctx->ATIFragmentShader.Current->cur_pass == 0) ||
      (ctx->ATIFragmentShader.Current->cur_pass == 2)) {
      }
   if (ctx->ATIFragmentShader.Current->cur_pass > 1)
         else
                  #if MESA_DEBUG_ATI_FS
      for (j = 0; j < MAX_NUM_PASSES_ATI; j++) {
      GLuint op = curProg->SetupInst[j][i].Opcode;
   const char *op_enum = op > 5 ? _mesa_enum_to_string(op) : "0";
   GLuint src = curProg->SetupInst[j][i].src;
   GLuint swizzle = curProg->SetupInst[j][i].swizzle;
   fprintf(stderr, "%2d %04X %s %d %04X\n", i, op, op_enum, src,
         swizzle);
   }
   GLuint op0 = curProg->Instructions[j][i].Opcode[0];
   GLuint op1 = curProg->Instructions[j][i].Opcode[1];
   const char *op0_enum = op0 > 5 ? _mesa_enum_to_string(op0) : "0";
   const char *op1_enum = op1 > 5 ? _mesa_enum_to_string(op1) : "0";
   GLuint count0 = curProg->Instructions[j][i].ArgCount[0];
   GLuint count1 = curProg->Instructions[j][i].ArgCount[1];
   fprintf(stderr, "%2d %04X %s %d %04X %s %d\n", i, op0, op0_enum, count0,
         op1, op1_enum, count1);
         #endif
         struct gl_program *prog = new_ati_fs(ctx,
         _mesa_reference_program(ctx, &ctx->ATIFragmentShader.Current->Program,
         /* Don't use _mesa_reference_program(), just take ownership */
            prog->SamplersUsed = 0;
            /* fill in SamplersUsed, TexturesUsed */
   for (unsigned pass = 0; pass < curProg->NumPasses; pass++) {
      for (unsigned r = 0; r < MAX_NUM_FRAGMENT_REGISTERS_ATI; r++) {
               if (texinst->Opcode == ATI_FRAGMENT_SHADER_SAMPLE_OP) {
      /* by default there is 1:1 mapping between samplers and textures */
   prog->SamplersUsed |= (1 << r);
   /* the target is unknown here, it will be fixed in the draw call */
                     /* we always have the ATI_fs constants */
   for (unsigned i = 0; i < MAX_NUM_FRAGMENT_CONSTANTS_ATI; i++) {
      _mesa_add_parameter(prog->Parameters, PROGRAM_UNIFORM,
               if (!st_program_string_notify(ctx, GL_FRAGMENT_SHADER_ATI,
            ctx->ATIFragmentShader.Current->isValid = GL_FALSE;
   /* XXX is this the right error? */
   _mesa_error(ctx, GL_INVALID_OPERATION,
         }
      void GLAPIENTRY
   _mesa_PassTexCoordATI(GLuint dst, GLuint coord, GLenum swizzle)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct ati_fragment_shader *curProg = ctx->ATIFragmentShader.Current;
   struct atifs_setupinst *curI;
            if (!ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPassTexCoordATI(outsideShader)");
               if (curProg->cur_pass == 1)
         if ((new_pass > 2) ||
      ((1 << (dst - GL_REG_0_ATI)) & curProg->regsAssigned[new_pass >> 1])) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "glPassTexCoord(pass)");
      }
   if ((dst < GL_REG_0_ATI) || (dst > GL_REG_5_ATI) ||
      ((dst - GL_REG_0_ATI) >= ctx->Const.MaxTextureUnits)) {
   _mesa_error(ctx, GL_INVALID_ENUM, "glPassTexCoordATI(dst)");
      }
   if (((coord < GL_REG_0_ATI) || (coord > GL_REG_5_ATI)) &&
      ((coord < GL_TEXTURE0_ARB) || (coord > GL_TEXTURE7_ARB) ||
   ((coord - GL_TEXTURE0_ARB) >= ctx->Const.MaxTextureUnits))) {
   _mesa_error(ctx, GL_INVALID_ENUM, "glPassTexCoordATI(coord)");
      }
   if ((new_pass == 0) && (coord >= GL_REG_0_ATI)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPassTexCoordATI(coord)");
      }
   if (!(swizzle >= GL_SWIZZLE_STR_ATI) && (swizzle <= GL_SWIZZLE_STQ_DQ_ATI)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glPassTexCoordATI(swizzle)");
      }
   if ((swizzle & 1) && (coord >= GL_REG_0_ATI)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPassTexCoordATI(swizzle)");
      }
   if (coord <= GL_TEXTURE7_ARB) {
      GLuint tmp = coord - GL_TEXTURE0_ARB;
         _mesa_error(ctx, GL_INVALID_OPERATION, "glPassTexCoordATI(swizzle)");
   return;
         curProg->swizzlerq |= (((swizzle & 1) + 1) << (tmp * 2));
                     if (curProg->cur_pass == 1)
         curProg->cur_pass = new_pass;
            /* add the instructions */
            curI->Opcode = ATI_FRAGMENT_SHADER_PASS_OP;
   curI->src = coord;
         #if MESA_DEBUG_ATI_FS
      _mesa_debug(ctx, "%s(%s, %s, %s)\n", __func__,
      _mesa_enum_to_string(dst), _mesa_enum_to_string(coord),
   #endif
   }
      void GLAPIENTRY
   _mesa_SampleMapATI(GLuint dst, GLuint interp, GLenum swizzle)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct ati_fragment_shader *curProg = ctx->ATIFragmentShader.Current;
   struct atifs_setupinst *curI;
            if (!ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMapATI(outsideShader)");
               if (curProg->cur_pass == 1)
         if ((new_pass > 2) ||
      ((1 << (dst - GL_REG_0_ATI)) & curProg->regsAssigned[new_pass >> 1])) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMapATI(pass)");
      }
   if ((dst < GL_REG_0_ATI) || (dst > GL_REG_5_ATI) ||
      ((dst - GL_REG_0_ATI) >= ctx->Const.MaxTextureUnits)) {
   _mesa_error(ctx, GL_INVALID_ENUM, "glSampleMapATI(dst)");
      }
   if (((interp < GL_REG_0_ATI) || (interp > GL_REG_5_ATI)) &&
      ((interp < GL_TEXTURE0_ARB) || (interp > GL_TEXTURE7_ARB) ||
      /* is this texture5 or texture7? spec is a bit unclear there */
      _mesa_error(ctx, GL_INVALID_ENUM, "glSampleMapATI(interp)");
      }
   if ((new_pass == 0) && (interp >= GL_REG_0_ATI)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMapATI(interp)");
      }
   if (!(swizzle >= GL_SWIZZLE_STR_ATI) && (swizzle <= GL_SWIZZLE_STQ_DQ_ATI)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glSampleMapATI(swizzle)");
      }
   if ((swizzle & 1) && (interp >= GL_REG_0_ATI)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMapATI(swizzle)");
      }
   if (interp <= GL_TEXTURE7_ARB) {
      GLuint tmp = interp - GL_TEXTURE0_ARB;
         _mesa_error(ctx, GL_INVALID_OPERATION, "glSampleMapATI(swizzle)");
   return;
         curProg->swizzlerq |= (((swizzle & 1) + 1) << (tmp * 2));
                     if (curProg->cur_pass == 1)
         curProg->cur_pass = new_pass;
            /* add the instructions */
            curI->Opcode = ATI_FRAGMENT_SHADER_SAMPLE_OP;
   curI->src = interp;
         #if MESA_DEBUG_ATI_FS
      _mesa_debug(ctx, "%s(%s, %s, %s)\n", __func__,
      _mesa_enum_to_string(dst), _mesa_enum_to_string(interp),
   #endif
   }
      static void
   _mesa_FragmentOpXATI(GLint optype, GLuint arg_count, GLenum op, GLuint dst,
         GLuint dstMask, GLuint dstMod, GLuint arg1,
   GLuint arg1Rep, GLuint arg1Mod, GLuint arg2,
   GLuint arg2Rep, GLuint arg2Mod, GLuint arg3,
   {
      GET_CURRENT_CONTEXT(ctx);
   struct ati_fragment_shader *curProg = ctx->ATIFragmentShader.Current;
   GLint ci;
   struct atifs_instruction *curI;
   GLuint modtemp = dstMod & ~GL_SATURATE_BIT_ATI;
   GLubyte new_pass = curProg->cur_pass;
            if (!ctx->ATIFragmentShader.Compiling) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "C/AFragmentOpATI(outsideShader)");
               if (curProg->cur_pass == 0)
         else if (curProg->cur_pass == 2)
                     /* Decide whether this is a new instruction or not. All color instructions
   * are new, and alpha instructions might also be new if there was no
   * preceding color inst. This may also be the first inst of the pass
   */
   if (optype == ATI_FRAGMENT_SHADER_COLOR_OP ||
      curProg->last_optype == optype ||
   curProg->numArithInstr[new_pass >> 1] == 0) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "C/AFragmentOpATI(instrCount)");
   return;
         }
      }
   ci = numArithInstr - 1;
            /* error checking */
   if ((dst < GL_REG_0_ATI) || (dst > GL_REG_5_ATI)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "C/AFragmentOpATI(dst)");
      }
   if ((modtemp != GL_NONE) && (modtemp != GL_2X_BIT_ATI) &&
      (modtemp != GL_4X_BIT_ATI) && (modtemp != GL_8X_BIT_ATI) &&
   (modtemp != GL_HALF_BIT_ATI) && (modtemp != GL_QUARTER_BIT_ATI) &&
   (modtemp != GL_EIGHTH_BIT_ATI)) {
   _mesa_error(ctx, GL_INVALID_ENUM, "C/AFragmentOpATI(dstMod)%x", modtemp);
      }
   /* op checking? Actually looks like that's missing in the spec but we'll do it anyway */
   if (((op < GL_ADD_ATI) || (op > GL_DOT2_ADD_ATI)) && !(op == GL_MOV_ATI)) {
      _mesa_error(ctx, GL_INVALID_ENUM, "C/AFragmentOpATI(op)");
      }
   if (optype == ATI_FRAGMENT_SHADER_ALPHA_OP) {
      ((op == GL_DOT3_ATI) && (curI->Opcode[0] != GL_DOT3_ATI)) ||
   ((op == GL_DOT4_ATI) && (curI->Opcode[0] != GL_DOT4_ATI)) ||
   ((op != GL_DOT4_ATI) && (curI->Opcode[0] == GL_DOT4_ATI))) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "AFragmentOpATI(op)");
   return;
            }
   /* The ATI_fragment_shader spec says:
   *
   *        The error INVALID_OPERATION is generated by... ColorFragmentOp2ATI
   *        if <op> is DOT4_ATI and <argN> is SECONDARY_INTERPOLATOR_ATI and
   *        <argNRep> is ALPHA or NONE.
   */
   if (optype == ATI_FRAGMENT_SHADER_COLOR_OP && op == GL_DOT4_ATI &&
      ((arg1 == GL_SECONDARY_INTERPOLATOR_ATI && (arg1Rep == GL_ALPHA || arg1Rep == GL_NONE)) ||
   (arg2 == GL_SECONDARY_INTERPOLATOR_ATI && (arg2Rep == GL_ALPHA || arg2Rep == GL_NONE)))) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "C/AFragmentOpATI(sec_interpDOT4)");
               if (!check_arith_arg(optype, arg1, arg1Rep)) {
         }
   if (arg2) {
      return;
            }
   if (arg3) {
      return;
         }
      (arg2 >= GL_CON_0_ATI) && (arg2 <= GL_CON_7_ATI) &&
   (arg3 >= GL_CON_0_ATI) && (arg3 <= GL_CON_7_ATI) &&
      _mesa_error(ctx, GL_INVALID_OPERATION, "C/AFragmentOpATI(3Consts)");
   return;
                              curProg->interpinp1 |= check_arg_color(new_pass, arg1);
   if (arg2)
         if (arg3)
            curProg->numArithInstr[new_pass >> 1] = numArithInstr;
   curProg->last_optype = optype;
            curI->Opcode[optype] = op;
   curI->SrcReg[optype][0].Index = arg1;
   curI->SrcReg[optype][0].argRep = arg1Rep;
   curI->SrcReg[optype][0].argMod = arg1Mod;
            if (arg2) {
      curI->SrcReg[optype][1].Index = arg2;
   curI->SrcReg[optype][1].argRep = arg2Rep;
               if (arg3) {
      curI->SrcReg[optype][2].Index = arg3;
   curI->SrcReg[optype][2].argRep = arg3Rep;
               curI->DstReg[optype].Index = dst;
   curI->DstReg[optype].dstMod = dstMod;
   /* From the ATI_fs spec:
   *
   *     "The <dstMask> parameter specifies which of the color components in
   *      <dst> will be written (ColorFragmentOp[1..3]ATI only).  This can
   *      either be NONE, in which case there is no mask and everything is
   *      written, or the bitwise-or of RED_BIT_ATI, GREEN_BIT_ATI, and
   *      BLUE_BIT_ATI."
   *
   * For AlphaFragmentOp, it always writes alpha.
   */
   if (optype == ATI_FRAGMENT_SHADER_ALPHA_OP)
         else if (dstMask == GL_NONE)
         else
         #if MESA_DEBUG_ATI_FS
         #endif
      }
      void GLAPIENTRY
   _mesa_ColorFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMask,
      GLuint dstMod, GLuint arg1, GLuint arg1Rep,
      {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_COLOR_OP, 1, op, dst, dstMask,
      }
      void GLAPIENTRY
   _mesa_ColorFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMask,
      GLuint dstMod, GLuint arg1, GLuint arg1Rep,
   GLuint arg1Mod, GLuint arg2, GLuint arg2Rep,
      {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_COLOR_OP, 2, op, dst, dstMask,
   dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep,
      }
      void GLAPIENTRY
   _mesa_ColorFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMask,
      GLuint dstMod, GLuint arg1, GLuint arg1Rep,
   GLuint arg1Mod, GLuint arg2, GLuint arg2Rep,
   GLuint arg2Mod, GLuint arg3, GLuint arg3Rep,
      {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_COLOR_OP, 3, op, dst, dstMask,
   dstMod, arg1, arg1Rep, arg1Mod, arg2, arg2Rep,
      }
      void GLAPIENTRY
   _mesa_AlphaFragmentOp1ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
         {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_ALPHA_OP, 1, op, dst, 0, dstMod,
      }
      void GLAPIENTRY
   _mesa_AlphaFragmentOp2ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
      GLuint arg1Rep, GLuint arg1Mod, GLuint arg2,
      {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_ALPHA_OP, 2, op, dst, 0, dstMod,
   arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, 0, 0,
      }
      void GLAPIENTRY
   _mesa_AlphaFragmentOp3ATI(GLenum op, GLuint dst, GLuint dstMod, GLuint arg1,
      GLuint arg1Rep, GLuint arg1Mod, GLuint arg2,
   GLuint arg2Rep, GLuint arg2Mod, GLuint arg3,
      {
      _mesa_FragmentOpXATI(ATI_FRAGMENT_SHADER_ALPHA_OP, 3, op, dst, 0, dstMod,
   arg1, arg1Rep, arg1Mod, arg2, arg2Rep, arg2Mod, arg3,
      }
      void GLAPIENTRY
   _mesa_SetFragmentShaderConstantATI(GLuint dst, const GLfloat * value)
   {
      GLuint dstindex;
            if ((dst < GL_CON_0_ATI) || (dst > GL_CON_7_ATI)) {
      /* spec says nothing about what should happen here but we can't just segfault...*/
   _mesa_error(ctx, GL_INVALID_ENUM, "glSetFragmentShaderConstantATI(dst)");
               dstindex = dst - GL_CON_0_ATI;
   if (ctx->ATIFragmentShader.Compiling) {
      struct ati_fragment_shader *curProg = ctx->ATIFragmentShader.Current;
   COPY_4V(curProg->Constants[dstindex], value);
      }
   else {
      FLUSH_VERTICES(ctx, 0, 0);
   ctx->NewDriverState |= ST_NEW_FS_CONSTANTS;
         }
