   /*
   * Mesa 3-D graphics library
   *
   * Copyright (C) 1999-2008  Brian Paul   All Rights Reserved.
   * Copyright (C) 2009  VMware, Inc.  All Rights Reserved.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included
   * in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
   * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   * OTHER DEALINGS IN THE SOFTWARE.
   */
         #include <stdio.h>
   #include <inttypes.h>  /* for PRId64 macro */
      #include "util/glheader.h"
      #include "bufferobj.h"
   #include "context.h"
   #include "enable.h"
   #include "enums.h"
   #include "glformats.h"
   #include "hash.h"
   #include "image.h"
   #include "macros.h"
   #include "mtypes.h"
   #include "varray.h"
   #include "arrayobj.h"
   #include "get.h"
   #include "main/dispatch.h"
   #include "api_exec_decl.h"
      #include "state_tracker/st_atom.h"
   #include "state_tracker/st_util.h"
      /* The values are multiplied by the component count to get the attrib size.
   * Indexed by PERF_HASH_GL_TYPE(GLenum).
   * Generated by src/util/tools/find_hash_func.c.
   */
   const uint8_t _mesa_vertex_type_bytes[16] = {
      /* These elements are listed out of order. */
   [/* 7*/ PERF_HASH_GL_VERTEX_TYPE(GL_BYTE)] = 1,
   [/* 8*/ PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_BYTE)] = 1,
   [/* 5*/ PERF_HASH_GL_VERTEX_TYPE(GL_INT_2_10_10_10_REV)] = 1, /* count is 4 */
   [/* 0*/ PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_INT_2_10_10_10_REV)] = 1, /* count is 4 */
   [/* 9*/ PERF_HASH_GL_VERTEX_TYPE(GL_SHORT)] = 2,
   [/*10*/ PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_SHORT)] = 2,
   [/* 2*/ PERF_HASH_GL_VERTEX_TYPE(GL_HALF_FLOAT_ARB)] = 2,
   [/* 4*/ PERF_HASH_GL_VERTEX_TYPE(GL_HALF_FLOAT_OES)] = 2,
   [/*11*/ PERF_HASH_GL_VERTEX_TYPE(GL_INT)] = 4,
   [/*12*/ PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_INT)] = 4,
   [/*13*/ PERF_HASH_GL_VERTEX_TYPE(GL_FLOAT)] = 4,
   [/* 3*/ PERF_HASH_GL_VERTEX_TYPE(GL_FIXED)] = 4,
   [/* 1*/ PERF_HASH_GL_VERTEX_TYPE(GL_DOUBLE)] = 8,
      };
      static inline void
   compile_check_uniqueness_of_gl_vertex_type(unsigned x)
   {
      /* This switch has the same purpose as static_assert.
   * It should fail compilation if any case is not unique.
   */
   switch (x) {
   case PERF_HASH_GL_VERTEX_TYPE(GL_BYTE):
   case PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_BYTE):
   case PERF_HASH_GL_VERTEX_TYPE(GL_INT_2_10_10_10_REV):
   case PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_INT_2_10_10_10_REV):
   case PERF_HASH_GL_VERTEX_TYPE(GL_SHORT):
   case PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_SHORT):
   case PERF_HASH_GL_VERTEX_TYPE(GL_HALF_FLOAT_ARB):
   case PERF_HASH_GL_VERTEX_TYPE(GL_HALF_FLOAT_OES):
   case PERF_HASH_GL_VERTEX_TYPE(GL_INT):
   case PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_INT):
   case PERF_HASH_GL_VERTEX_TYPE(GL_FLOAT):
   case PERF_HASH_GL_VERTEX_TYPE(GL_FIXED):
   case PERF_HASH_GL_VERTEX_TYPE(GL_DOUBLE):
   case PERF_HASH_GL_VERTEX_TYPE(GL_UNSIGNED_INT64_ARB):
            }
      /** Used to do error checking for GL_EXT_vertex_array_bgra */
   #define BGRA_OR_4  5
         /** Used to indicate which GL datatypes are accepted by each of the
   * glVertex/Color/Attrib/EtcPointer() functions.
   */
   #define BOOL_BIT                          (1 << 0)
   #define BYTE_BIT                          (1 << 1)
   #define UNSIGNED_BYTE_BIT                 (1 << 2)
   #define SHORT_BIT                         (1 << 3)
   #define UNSIGNED_SHORT_BIT                (1 << 4)
   #define INT_BIT                           (1 << 5)
   #define UNSIGNED_INT_BIT                  (1 << 6)
   #define HALF_BIT                          (1 << 7)
   #define FLOAT_BIT                         (1 << 8)
   #define DOUBLE_BIT                        (1 << 9)
   #define FIXED_ES_BIT                      (1 << 10)
   #define FIXED_GL_BIT                      (1 << 11)
   #define UNSIGNED_INT_2_10_10_10_REV_BIT   (1 << 12)
   #define INT_2_10_10_10_REV_BIT            (1 << 13)
   #define UNSIGNED_INT_10F_11F_11F_REV_BIT  (1 << 14)
   #define UNSIGNED_INT64_BIT                (1 << 15)
   #define ALL_TYPE_BITS                    ((1 << 16) - 1)
      #define ATTRIB_FORMAT_TYPES_MASK (BYTE_BIT | UNSIGNED_BYTE_BIT | \
                                    SHORT_BIT | UNSIGNED_SHORT_BIT | \
         #define ATTRIB_IFORMAT_TYPES_MASK (BYTE_BIT | UNSIGNED_BYTE_BIT | \
                  #define ATTRIB_LFORMAT_TYPES_MASK (DOUBLE_BIT | UNSIGNED_INT64_BIT)
         /** Convert GL datatype enum into a <type>_BIT value seen above */
   static GLbitfield
   type_to_bit(const struct gl_context *ctx, GLenum type)
   {
      switch (type) {
   case GL_BOOL:
         case GL_BYTE:
         case GL_UNSIGNED_BYTE:
         case GL_SHORT:
         case GL_UNSIGNED_SHORT:
         case GL_INT:
         case GL_UNSIGNED_INT:
         case GL_HALF_FLOAT:
   case GL_HALF_FLOAT_OES:
      if (ctx->Extensions.ARB_half_float_vertex)
         else
      case GL_FLOAT:
         case GL_DOUBLE:
         case GL_FIXED:
         case GL_UNSIGNED_INT_2_10_10_10_REV:
         case GL_INT_2_10_10_10_REV:
         case GL_UNSIGNED_INT_10F_11F_11F_REV:
         default:
            }
         /**
   * Depending on the position and generic0 attributes enable flags select
   * the one that is used for both attributes.
   * The generic0 attribute takes precedence.
   */
   static inline void
   update_attribute_map_mode(const struct gl_context *ctx,
         {
      /*
   * There is no need to change the mapping away from the
   * identity mapping if we are not in compat mode.
   */
   if (ctx->API != API_OPENGL_COMPAT)
         /* The generic0 attribute superseeds the position attribute */
   const GLbitfield enabled = vao->Enabled;
   if (enabled & VERT_BIT_GENERIC0)
         else if (enabled & VERT_BIT_POS)
         else
      }
         /**
   * Sets the BufferBindingIndex field for the vertex attribute given by
   * attribIndex.
   */
   void
   _mesa_vertex_attrib_binding(struct gl_context *ctx,
                     {
      struct gl_array_attributes *array = &vao->VertexAttrib[attribIndex];
            if (array->BufferBindingIndex != bindingIndex) {
               if (vao->BufferBinding[bindingIndex].BufferObj)
         else
            if (vao->BufferBinding[bindingIndex].InstanceDivisor)
         else
            vao->BufferBinding[array->BufferBindingIndex]._BoundArrays &= ~array_bit;
                     if (vao->Enabled & array_bit) {
      ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
                     }
         /**
   * Binds a buffer object to the vertex buffer binding point given by index,
   * and sets the Offset and Stride fields.
   */
   void
   _mesa_bind_vertex_buffer(struct gl_context *ctx,
                           struct gl_vertex_array_object *vao,
   {
      assert(index < ARRAY_SIZE(vao->BufferBinding));
   assert(!vao->SharedAndImmutable);
            if (ctx->Const.VertexBufferOffsetIsInt32 && (int)offset < 0 &&
      !offset_is_int32 && vbo) {
   /* The offset will be interpreted as a signed int, so make sure
   * the user supplied offset is not negative (driver limitation).
   */
                  /* We can't disable this binding, so use a non-negative offset value
   * instead.
   */
               if (binding->BufferObj != vbo ||
      binding->Offset != offset ||
   binding->Stride != stride) {
            if (take_vbo_ownership) {
      _mesa_reference_buffer_object(ctx, &binding->BufferObj, NULL);
      } else {
                  binding->Offset = offset;
            if (!vbo) {
         } else {
      vao->VertexAttribBufferMask |= binding->_BoundArrays;
               if (vao->Enabled & binding->_BoundArrays) {
      ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
   /* Non-dynamic VAOs merge vertex buffers, which affects vertex elements.
   * stride changes also require new vertex elements
   */
   if (!vao->IsDynamic || stride_changed)
                  } else {
      /* Since this function owns the vbo reference, it must release it if it
   * doesn't use it.
   */
   if (take_vbo_ownership)
         }
         /**
   * Sets the InstanceDivisor field in the vertex buffer binding point
   * given by bindingIndex.
   */
   static void
   vertex_binding_divisor(struct gl_context *ctx,
                     {
      struct gl_vertex_buffer_binding *binding =
                  if (binding->InstanceDivisor != divisor) {
               if (divisor)
         else
            if (vao->Enabled & binding->_BoundArrays) {
      ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
                     }
      /* vertex_formats[(gltype & 0x3f) | (double << 5)][integer*2 + normalized][size - 1] */
   static const uint8_t vertex_formats[][4][4] = {
      { /* GL_BYTE */
      {
      PIPE_FORMAT_R8_SSCALED,
   PIPE_FORMAT_R8G8_SSCALED,
   PIPE_FORMAT_R8G8B8_SSCALED,
      },
   {
      PIPE_FORMAT_R8_SNORM,
   PIPE_FORMAT_R8G8_SNORM,
   PIPE_FORMAT_R8G8B8_SNORM,
      },
   {
      PIPE_FORMAT_R8_SINT,
   PIPE_FORMAT_R8G8_SINT,
   PIPE_FORMAT_R8G8B8_SINT,
         },
   { /* GL_UNSIGNED_BYTE */
      {
      PIPE_FORMAT_R8_USCALED,
   PIPE_FORMAT_R8G8_USCALED,
   PIPE_FORMAT_R8G8B8_USCALED,
      },
   {
      PIPE_FORMAT_R8_UNORM,
   PIPE_FORMAT_R8G8_UNORM,
   PIPE_FORMAT_R8G8B8_UNORM,
      },
   {
      PIPE_FORMAT_R8_UINT,
   PIPE_FORMAT_R8G8_UINT,
   PIPE_FORMAT_R8G8B8_UINT,
         },
   { /* GL_SHORT */
      {
      PIPE_FORMAT_R16_SSCALED,
   PIPE_FORMAT_R16G16_SSCALED,
   PIPE_FORMAT_R16G16B16_SSCALED,
      },
   {
      PIPE_FORMAT_R16_SNORM,
   PIPE_FORMAT_R16G16_SNORM,
   PIPE_FORMAT_R16G16B16_SNORM,
      },
   {
      PIPE_FORMAT_R16_SINT,
   PIPE_FORMAT_R16G16_SINT,
   PIPE_FORMAT_R16G16B16_SINT,
         },
   { /* GL_UNSIGNED_SHORT */
      {
      PIPE_FORMAT_R16_USCALED,
   PIPE_FORMAT_R16G16_USCALED,
   PIPE_FORMAT_R16G16B16_USCALED,
      },
   {
      PIPE_FORMAT_R16_UNORM,
   PIPE_FORMAT_R16G16_UNORM,
   PIPE_FORMAT_R16G16B16_UNORM,
      },
   {
      PIPE_FORMAT_R16_UINT,
   PIPE_FORMAT_R16G16_UINT,
   PIPE_FORMAT_R16G16B16_UINT,
         },
   { /* GL_INT */
      {
      PIPE_FORMAT_R32_SSCALED,
   PIPE_FORMAT_R32G32_SSCALED,
   PIPE_FORMAT_R32G32B32_SSCALED,
      },
   {
      PIPE_FORMAT_R32_SNORM,
   PIPE_FORMAT_R32G32_SNORM,
   PIPE_FORMAT_R32G32B32_SNORM,
      },
   {
      PIPE_FORMAT_R32_SINT,
   PIPE_FORMAT_R32G32_SINT,
   PIPE_FORMAT_R32G32B32_SINT,
         },
   { /* GL_UNSIGNED_INT */
      {
      PIPE_FORMAT_R32_USCALED,
   PIPE_FORMAT_R32G32_USCALED,
   PIPE_FORMAT_R32G32B32_USCALED,
      },
   {
      PIPE_FORMAT_R32_UNORM,
   PIPE_FORMAT_R32G32_UNORM,
   PIPE_FORMAT_R32G32B32_UNORM,
      },
   {
      PIPE_FORMAT_R32_UINT,
   PIPE_FORMAT_R32G32_UINT,
   PIPE_FORMAT_R32G32B32_UINT,
         },
   { /* GL_FLOAT */
      {
      PIPE_FORMAT_R32_FLOAT,
   PIPE_FORMAT_R32G32_FLOAT,
   PIPE_FORMAT_R32G32B32_FLOAT,
      },
   {
      PIPE_FORMAT_R32_FLOAT,
   PIPE_FORMAT_R32G32_FLOAT,
   PIPE_FORMAT_R32G32B32_FLOAT,
         },
   {{0}}, /* GL_2_BYTES */
   {{0}}, /* GL_3_BYTES */
   {{0}}, /* GL_4_BYTES */
   { /* GL_DOUBLE */
      {
      PIPE_FORMAT_R64_FLOAT,
   PIPE_FORMAT_R64G64_FLOAT,
   PIPE_FORMAT_R64G64B64_FLOAT,
      },
   {
      PIPE_FORMAT_R64_FLOAT,
   PIPE_FORMAT_R64G64_FLOAT,
   PIPE_FORMAT_R64G64B64_FLOAT,
         },
   { /* GL_HALF_FLOAT */
      {
      PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
      },
   {
      PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
         },
   { /* GL_FIXED */
      {
      PIPE_FORMAT_R32_FIXED,
   PIPE_FORMAT_R32G32_FIXED,
   PIPE_FORMAT_R32G32B32_FIXED,
      },
   {
      PIPE_FORMAT_R32_FIXED,
   PIPE_FORMAT_R32G32_FIXED,
   PIPE_FORMAT_R32G32B32_FIXED,
         },
   {{0}}, /* unused (13) */
   {{0}}, /* unused (14) */
   {{0}}, /* unused (15) */
   {{0}}, /* unused (16) */
   {{0}}, /* unused (17) */
   {{0}}, /* unused (18) */
   {{0}}, /* unused (19) */
   {{0}}, /* unused (20) */
   {{0}}, /* unused (21) */
   {{0}}, /* unused (22) */
   {{0}}, /* unused (23) */
   {{0}}, /* unused (24) */
   {{0}}, /* unused (25) */
   {{0}}, /* unused (26) */
   {{0}}, /* unused (27) */
   {{0}}, /* unused (28) */
   {{0}}, /* unused (29) */
   {{0}}, /* unused (30) */
   { /* GL_INT_2_10_10_10_REV */
      {
      0,
   0,
   0,
      },
   {
      0,
   0,
   0,
         },
   {{0}}, /* unused (32) */
   { /* GL_HALF_FLOAT_OES */
      {
      PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
      },
   {
      PIPE_FORMAT_R16_FLOAT,
   PIPE_FORMAT_R16G16_FLOAT,
   PIPE_FORMAT_R16G16B16_FLOAT,
         },
   {{0}}, /* unused (34) */
   {{0}}, /* unused (35) */
   {{0}}, /* unused (36) */
   {{0}}, /* unused (37) */
   {{0}}, /* unused (38) */
   {{0}}, /* unused (39) */
   { /* GL_UNSIGNED_INT_2_10_10_10_REV */
      {
      0,
   0,
   0,
      },
   {
      0,
   0,
   0,
         },
   {{0}}, /* unused (41) */
   { /* GL_DOUBLE | (doubles << 5) (real double) */
   {
      PIPE_FORMAT_R64_UINT,
   PIPE_FORMAT_R64G64_UINT,
   PIPE_FORMAT_R64G64B64_UINT,
      },
   },
   {{0}}, /* unused (43) */
   {{0}}, /* unused (44) */
   {{0}}, /* unused (45) */
   {{0}}, /* unused (46) */
   { /* GL_UNSIGNED_INT64_ARB | (doubles << 5) (doubles is always true) */
   {0},
   {0},
   {
      PIPE_FORMAT_R64_UINT,
   PIPE_FORMAT_R64G64_UINT,
   PIPE_FORMAT_R64G64B64_UINT,
      },
   },
   {{0}}, /* unused (48) */
   {{0}}, /* unused (49) */
   {{0}}, /* unused (50) */
   {{0}}, /* unused (51) */
   {{0}}, /* unused (52) */
   {{0}}, /* unused (53) */
   {{0}}, /* unused (54) */
   {{0}}, /* unused (55) */
   {{0}}, /* unused (56) */
   {{0}}, /* unused (57) */
   {{0}}, /* unused (58) */
   { /* GL_UNSIGNED_INT_10F_11F_11F_REV */
      {
      0,
   0,
   PIPE_FORMAT_R11G11B10_FLOAT,
      },
   {
      0,
   0,
   PIPE_FORMAT_R11G11B10_FLOAT,
            };
      /* bgra_vertex_formats[type & 0x3][normalized] */
   static const uint8_t bgra_vertex_formats[4][2] = {
      { /* GL_UNSIGNED_INT_2_10_10_10_REV */
      PIPE_FORMAT_B10G10R10A2_USCALED,
      },
   { /* GL_UNSIGNED_BYTE */
      0,
      },
   {0}, /* unused (2) */
   { /* GL_INT_2_10_10_10_REV */
      PIPE_FORMAT_B10G10R10A2_SSCALED,
         };
      /**
   * Return a PIPE_FORMAT_x for the given GL datatype and size.
   */
   static enum pipe_format
   vertex_format_to_pipe_format(GLubyte size, GLenum16 type, GLenum16 format,
         {
      assert(size >= 1 && size <= 4);
            if (format == GL_BGRA) {
      assert(size == 4 && !integer);
   assert(type == GL_UNSIGNED_BYTE ||
                  enum pipe_format pipe_format =
         assert(pipe_format);
               unsigned index = integer*2 + normalized;
   assert(index <= 2);
   assert((type >= GL_BYTE && type <= GL_FIXED) ||
         type == GL_HALF_FLOAT_OES ||
   type == GL_INT_2_10_10_10_REV ||
   type == GL_UNSIGNED_INT_2_10_10_10_REV ||
            enum pipe_format pipe_format =
         assert(pipe_format);
      }
      static void
   set_vertex_format_user(union gl_vertex_format_user *vertex_format,
                     {
      assert(size <= 4);
   vertex_format->Type = type;
   vertex_format->Bgra = format == GL_BGRA;
   vertex_format->Size = size;
   vertex_format->Normalized = normalized;
   vertex_format->Integer = integer;
      }
      static void
   recompute_vertex_format_fields(struct gl_vertex_format *vertex_format,
                     {
      vertex_format->_ElementSize = _mesa_bytes_per_vertex_attrib(size, type);
   assert(vertex_format->_ElementSize <= 4*sizeof(double));
   vertex_format->_PipeFormat =
      vertex_format_to_pipe_format(size, type, format, normalized, integer,
      /* pipe_vertex_element::src_format has only 8 bits, assuming a signed enum */
      }
      void
   _mesa_set_vertex_format(struct gl_vertex_format *vertex_format,
                     {
      set_vertex_format_user(&vertex_format->User, size, type, format,
         recompute_vertex_format_fields(vertex_format, size, type, format,
      }
         /**
   * Examine the API profile and extensions to determine which types are legal
   * for vertex arrays.  This is called once from update_array_format().
   */
   static GLbitfield
   get_legal_types_mask(const struct gl_context *ctx)
   {
               if (_mesa_is_gles(ctx)) {
      legalTypesMask &= ~(FIXED_GL_BIT |
                        /* GL_INT and GL_UNSIGNED_INT data is not allowed in OpenGL ES until
   * 3.0.  The 2_10_10_10 types are added in OpenGL ES 3.0 or
   * GL_OES_vertex_type_10_10_10_2.  GL_HALF_FLOAT data is not allowed
   * until 3.0 or with the GL_OES_vertex_half float extension, which isn't
   * quite as trivial as we'd like because it uses a different enum value
   * for GL_HALF_FLOAT_OES.
   */
   if (ctx->Version < 30) {
      legalTypesMask &= ~(UNSIGNED_INT_BIT |
                        if (!_mesa_has_OES_vertex_half_float(ctx))
         }
   else {
               if (!ctx->Extensions.ARB_ES2_compatibility)
            if (!ctx->Extensions.ARB_vertex_type_2_10_10_10_rev)
                  if (!ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev)
            if (!ctx->Extensions.ARB_bindless_texture)
                  }
      static GLenum
   get_array_format(const struct gl_context *ctx, GLint sizeMax, GLint *size)
   {
               /* Do size parameter checking.
   * If sizeMax = BGRA_OR_4 it means that size = GL_BGRA is legal and
   * must be handled specially.
   */
   if (ctx->Extensions.EXT_vertex_array_bgra && sizeMax == BGRA_OR_4 &&
      *size == GL_BGRA) {
   format = GL_BGRA;
                  }
         /**
   * \param attrib         The index of the attribute array
   * \param size           Components per element (1, 2, 3 or 4)
   * \param type           Datatype of each component (GL_FLOAT, GL_INT, etc)
   * \param format         Either GL_RGBA or GL_BGRA.
   * \param normalized     Whether integer types are converted to floats in [-1, 1]
   * \param integer        Integer-valued values (will not be normalized to [-1, 1])
   * \param doubles        Double values not reduced to floats
   * \param relativeOffset Offset of the first element relative to the binding
   *                       offset.
   */
   void
   _mesa_update_array_format(struct gl_context *ctx,
                           struct gl_vertex_array_object *vao,
   {
      struct gl_array_attributes *const array = &vao->VertexAttrib[attrib];
            assert(!vao->SharedAndImmutable);
            set_vertex_format_user(&new_format, size, type, format,
            if (array->RelativeOffset == relativeOffset &&
      array->Format.User.All == new_format.All)
         array->RelativeOffset = relativeOffset;
   array->Format.User = new_format;
   recompute_vertex_format_fields(&array->Format, size, type, format,
            if (vao->Enabled & VERT_BIT(attrib)) {
      ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
                  }
      /**
   * Does error checking of the format in an attrib array.
   *
   * Called by *Pointer() and VertexAttrib*Format().
   *
   * \param func         Name of calling function used for error reporting
   * \param attrib       The index of the attribute array
   * \param legalTypes   Bitmask of *_BIT above indicating legal datatypes
   * \param sizeMin      Min allowable size value
   * \param sizeMax      Max allowable size value (may also be BGRA_OR_4)
   * \param size         Components per element (1, 2, 3 or 4)
   * \param type         Datatype of each component (GL_FLOAT, GL_INT, etc)
   * \param normalized   Whether integer types are converted to floats in [-1, 1]
   * \param integer      Integer-valued values (will not be normalized to [-1, 1])
   * \param doubles      Double values not reduced to floats
   * \param relativeOffset Offset of the first element relative to the binding offset.
   * \return bool True if validation is successful, False otherwise.
   */
   static bool
   validate_array_format(struct gl_context *ctx, const char *func,
                        struct gl_vertex_array_object *vao,
   GLuint attrib, GLbitfield legalTypesMask,
      {
               /* at most, one of these bools can be true */
            if (ctx->Array.LegalTypesMask == 0 || ctx->Array.LegalTypesMaskAPI != ctx->API) {
      /* Compute the LegalTypesMask only once, unless the context API has
   * changed, in which case we want to compute it again.  We can't do this
   * in _mesa_init_varrays() below because extensions are not yet enabled
   * at that point.
   */
   ctx->Array.LegalTypesMask = get_legal_types_mask(ctx);
                        if (_mesa_is_gles(ctx) && sizeMax == BGRA_OR_4) {
      /* BGRA ordering is not supported in ES contexts.
   */
               typeBit = type_to_bit(ctx, type);
   if (typeBit == 0x0 || (typeBit & legalTypesMask) == 0x0) {
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(type = %s)",
                     if (format == GL_BGRA) {
      /* Page 298 of the PDF of the OpenGL 4.3 (Core Profile) spec says:
   *
   * "An INVALID_OPERATION error is generated under any of the following
   *  conditions:
   *    ...
   *    • size is BGRA and type is not UNSIGNED_BYTE, INT_2_10_10_10_REV
   *      or UNSIGNED_INT_2_10_10_10_REV;
   *    ...
   *    • size is BGRA and normalized is FALSE;"
   */
            if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev) {
      if (type != GL_UNSIGNED_INT_2_10_10_10_REV &&
      type != GL_INT_2_10_10_10_REV &&
   type != GL_UNSIGNED_BYTE)
   } else if (type != GL_UNSIGNED_BYTE)
            if (bgra_error) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=GL_BGRA and type=%s)",
                     if (!normalized) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               }
   else if (size < sizeMin || size > sizeMax || size > 4) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(size=%d)", func, size);
               if (ctx->Extensions.ARB_vertex_type_2_10_10_10_rev &&
      (type == GL_UNSIGNED_INT_2_10_10_10_REV ||
   type == GL_INT_2_10_10_10_REV) && size != 4) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
               /* The ARB_vertex_attrib_binding_spec says:
   *
   *   An INVALID_VALUE error is generated if <relativeoffset> is larger than
   *   the value of MAX_VERTEX_ATTRIB_RELATIVE_OFFSET.
   */
   if (relativeOffset > ctx->Const.MaxVertexAttribRelativeOffset) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(relativeOffset=%d > "
               if (ctx->Extensions.ARB_vertex_type_10f_11f_11f_rev &&
            _mesa_error(ctx, GL_INVALID_OPERATION, "%s(size=%d)", func, size);
                  }
      /**
   * Do error checking for glVertex/Color/TexCoord/...Pointer functions.
   *
   * \param func  name of calling function used for error reporting
   * \param vao the vao to update
   * \param obj the bound buffer object
   * \param attrib  the attribute array index to update
   * \param legalTypes  bitmask of *_BIT above indicating legal datatypes
   * \param sizeMin  min allowable size value
   * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
   * \param size  components per element (1, 2, 3 or 4)
   * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
   * \param stride  stride between elements, in elements
   * \param normalized  are integer types converted to floats in [-1, 1]?
   * \param integer  integer-valued values (will not be normalized to [-1,1])
   * \param doubles  Double values not reduced to floats
   * \param ptr  the address (or offset inside VBO) of the array data
   */
   static void
   validate_array(struct gl_context *ctx, const char *func,
                  struct gl_vertex_array_object *vao,
   struct gl_buffer_object *obj,
   GLuint attrib, GLbitfield legalTypesMask,
   GLint sizeMin, GLint sizeMax,
      {
      /* Page 407 (page 423 of the PDF) of the OpenGL 3.0 spec says:
   *
   *     "Client vertex arrays - all vertex array attribute pointers must
   *     refer to buffer objects (section 2.9.2). The default vertex array
   *     object (the name zero) is also deprecated. Calling
   *     VertexAttribPointer when no buffer object or no vertex array object
   *     is bound will generate an INVALID_OPERATION error..."
   *
   * The check for VBOs is handled below.
   */
   if (_mesa_is_desktop_gl_core(ctx) && (vao == ctx->Array.DefaultVAO)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(no array object bound)",
                     if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "%s(stride=%d)", func, stride );
               if (_mesa_is_desktop_gl(ctx) && ctx->Version >= 44 &&
      stride > ctx->Const.MaxVertexAttribStride) {
   _mesa_error(ctx, GL_INVALID_VALUE, "%s(stride=%d > "
                     /* Page 29 (page 44 of the PDF) of the OpenGL 3.3 spec says:
   *
   *     "An INVALID_OPERATION error is generated under any of the following
   *     conditions:
   *
   *     ...
   *
   *     * any of the *Pointer commands specifying the location and
   *       organization of vertex array data are called while zero is bound
   *       to the ARRAY_BUFFER buffer object binding point (see section
   *       2.9.6), and the pointer argument is not NULL."
   */
   if (ptr != NULL && vao != ctx->Array.DefaultVAO &&
      !obj) {
   _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-VBO array)", func);
         }
         static bool
   validate_array_and_format(struct gl_context *ctx, const char *func,
                           struct gl_vertex_array_object *vao,
   struct gl_buffer_object *obj,
   GLuint attrib, GLbitfield legalTypes,
   {
      validate_array(ctx, func, vao, obj, attrib, legalTypes, sizeMin, sizeMax,
            return validate_array_format(ctx, func, vao, attrib, legalTypes, sizeMin,
            }
         /**
   * Update state for glVertex/Color/TexCoord/...Pointer functions.
   *
   * \param vao the vao to update
   * \param obj the bound buffer object
   * \param attrib  the attribute array index to update
   * \param format  Either GL_RGBA or GL_BGRA.
   * \param sizeMax  max allowable size value (may also be BGRA_OR_4)
   * \param size  components per element (1, 2, 3 or 4)
   * \param type  datatype of each component (GL_FLOAT, GL_INT, etc)
   * \param stride  stride between elements, in elements
   * \param normalized  are integer types converted to floats in [-1, 1]?
   * \param integer  integer-valued values (will not be normalized to [-1,1])
   * \param doubles  Double values not reduced to floats
   * \param ptr  the address (or offset inside VBO) of the array data
   */
   static void
   update_array(struct gl_context *ctx,
               struct gl_vertex_array_object *vao,
   struct gl_buffer_object *obj,
   GLuint attrib, GLenum format,
   GLint sizeMax,
   GLint size, GLenum type, GLsizei stride,
   {
      _mesa_update_array_format(ctx, vao, attrib, size, type, format,
            /* Reset the vertex attrib binding */
            /* The Stride and Ptr fields are not set by update_array_format() */
   struct gl_array_attributes *array = &vao->VertexAttrib[attrib];
   if ((array->Stride != stride) || (array->Ptr != ptr)) {
      array->Stride = stride;
            if (vao->Enabled & VERT_BIT(attrib)) {
      ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
   /* Non-dynamic VAOs merge vertex buffers, which affects vertex elements. */
   if (!vao->IsDynamic)
                           /* Update the vertex buffer binding */
   GLsizei effectiveStride = stride != 0 ?
         _mesa_bind_vertex_buffer(ctx, vao, attrib,
            }
         /* Helper function for all EXT_direct_state_access glVertexArray* functions */
   static bool
   _lookup_vao_and_vbo_dsa(struct gl_context *ctx,
                           GLuint vaobj, GLuint buffer,
   {
      *vao = _mesa_lookup_vao_err(ctx, vaobj, true, caller);
   if (!(*vao))
            if (buffer != 0) {
      *vbo = _mesa_lookup_bufferobj(ctx, buffer);
   if (!_mesa_handle_bind_buffer_gen(ctx, buffer, vbo, caller, false))
            if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               } else {
                     }
         void GLAPIENTRY
   _mesa_VertexPointer_no_error(GLint size, GLenum type, GLsizei stride,
         {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               GLenum format = GL_RGBA;
   GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (SHORT_BIT | INT_BIT | FLOAT_BIT |
      DOUBLE_BIT | HALF_BIT |
            if (!validate_array_and_format(ctx, "glVertexPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexOffsetEXT(GLuint vaobj, GLuint buffer, GLint size,
         {
               GLenum format = GL_RGBA;
   GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (SHORT_BIT | INT_BIT | FLOAT_BIT |
      DOUBLE_BIT | HALF_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayVertexOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_NormalPointer_no_error(GLenum type, GLsizei stride, const GLvoid *ptr )
   {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_NormalPointer(GLenum type, GLsizei stride, const GLvoid *ptr )
   {
               GLenum format = GL_RGBA;
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (BYTE_BIT | SHORT_BIT | INT_BIT |
      HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            if (!validate_array_and_format(ctx, "glNormalPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayNormalOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type,
         {
               GLenum format = GL_RGBA;
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (BYTE_BIT | SHORT_BIT | INT_BIT |
      HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glNormalPointer",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_ColorPointer_no_error(GLint size, GLenum type, GLsizei stride,
         {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_ColorPointer(GLint size, GLenum type, GLsizei stride, const GLvoid *ptr)
   {
      GET_CURRENT_CONTEXT(ctx);
            GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (UNSIGNED_BYTE_BIT | HALF_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (BYTE_BIT | UNSIGNED_BYTE_BIT |
      SHORT_BIT | UNSIGNED_SHORT_BIT |
   INT_BIT | UNSIGNED_INT_BIT |
   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            if (!validate_array_and_format(ctx, "glColorPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size,
         {
      GET_CURRENT_CONTEXT(ctx);
            GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (UNSIGNED_BYTE_BIT | HALF_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (BYTE_BIT | UNSIGNED_BYTE_BIT |
      SHORT_BIT | UNSIGNED_SHORT_BIT |
   INT_BIT | UNSIGNED_INT_BIT |
   HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayColorOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_FogCoordPointer_no_error(GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_FogCoordPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               GLenum format = GL_RGBA;
            if (!validate_array_and_format(ctx, "glFogCoordPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayFogCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type,
         {
               GLenum format = GL_RGBA;
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayFogCoordOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_IndexPointer_no_error(GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_IndexPointer(GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               GLenum format = GL_RGBA;
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT | INT_BIT |
            if (!validate_array_and_format(ctx, "glIndexPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayIndexOffsetEXT(GLuint vaobj, GLuint buffer, GLenum type,
         {
               GLenum format = GL_RGBA;
   const GLbitfield legalTypes = (UNSIGNED_BYTE_BIT | SHORT_BIT | INT_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayIndexOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_SecondaryColorPointer_no_error(GLint size, GLenum type,
         {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_SecondaryColorPointer(GLint size, GLenum type,
         {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                    if (!validate_array_and_format(ctx, "glSecondaryColorPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArraySecondaryColorOffsetEXT(GLuint vaobj, GLuint buffer, GLint size,
         {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                    struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArraySecondaryColorOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_TexCoordPointer_no_error(GLint size, GLenum type, GLsizei stride,
         {
      GET_CURRENT_CONTEXT(ctx);
            update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_TexCoordPointer(GLint size, GLenum type, GLsizei stride,
         {
      GET_CURRENT_CONTEXT(ctx);
   const GLint sizeMin = _mesa_is_gles1(ctx) ? 2 : 1;
            GLenum format = GL_RGBA;
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (SHORT_BIT | INT_BIT |
      HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            if (!validate_array_and_format(ctx, "glTexCoordPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLint size,
         {
      GET_CURRENT_CONTEXT(ctx);
   const GLint sizeMin = _mesa_is_gles1(ctx) ? 2 : 1;
            GLenum format = GL_RGBA;
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (SHORT_BIT | INT_BIT |
      HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayTexCoordOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_VertexArrayMultiTexCoordOffsetEXT(GLuint vaobj, GLuint buffer, GLenum texunit,
               {
      GET_CURRENT_CONTEXT(ctx);
   const GLint sizeMin = _mesa_is_gles1(ctx) ? 2 : 1;
            GLenum format = GL_RGBA;
   const GLbitfield legalTypes = _mesa_is_gles1(ctx)
      ? (BYTE_BIT | SHORT_BIT | FLOAT_BIT | FIXED_ES_BIT)
   : (SHORT_BIT | INT_BIT |
      HALF_BIT | FLOAT_BIT | DOUBLE_BIT |
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (unit >= ctx->Const.MaxCombinedTextureImageUnits) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexArrayMultiTexCoordOffsetEXT(texunit=%d)",
                     if (!validate_array_and_format(ctx, "glVertexArrayMultiTexCoordOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_EdgeFlagPointer_no_error(GLsizei stride, const GLvoid *ptr)
   {
      /* this is the same type that glEdgeFlag uses */
   const GLboolean integer = GL_FALSE;
            update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_EdgeFlagPointer(GLsizei stride, const GLvoid *ptr)
   {
      /* this is the same type that glEdgeFlag uses */
   const GLboolean integer = GL_FALSE;
            GLenum format = GL_RGBA;
            if (!validate_array_and_format(ctx, "glEdgeFlagPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayEdgeFlagOffsetEXT(GLuint vaobj, GLuint buffer, GLsizei stride,
         {
      /* this is the same type that glEdgeFlag uses */
   const GLboolean integer = GL_FALSE;
            GLenum format = GL_RGBA;
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (!validate_array_and_format(ctx, "glVertexArrayEdgeFlagOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_PointSizePointerOES_no_error(GLenum type, GLsizei stride,
         {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_PointSizePointerOES(GLenum type, GLsizei stride, const GLvoid *ptr)
   {
               GLenum format = GL_RGBA;
   if (ctx->API != API_OPENGLES) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
                              if (!validate_array_and_format(ctx, "glPointSizePointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexAttribPointer_no_error(GLuint index, GLint size, GLenum type,
               {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         /**
   * Set a generic vertex attribute array.
   * Note that these arrays DO NOT alias the conventional GL vertex arrays
   * (position, normal, color, fog, texcoord, etc).
   */
   void GLAPIENTRY
   _mesa_VertexAttribPointer(GLuint index, GLint size, GLenum type,
               {
               GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribPointerARB(idx)");
               const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                 SHORT_BIT | UNSIGNED_SHORT_BIT |
            if (!validate_array_and_format(ctx, "glVertexAttribPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size,
               {
      GET_CURRENT_CONTEXT(ctx);
   GLenum format = get_array_format(ctx, BGRA_OR_4, &size);
   struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexArrayVertexAttribOffsetEXT(idx)");
               const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                                 SHORT_BIT | UNSIGNED_SHORT_BIT |
            if (!validate_array_and_format(ctx, "glVertexArrayVertexAttribOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribLOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size,
         {
      GET_CURRENT_CONTEXT(ctx);
   GLenum format = GL_RGBA;
   struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexArrayVertexAttribLOffsetEXT(idx)");
                        if (!validate_array_and_format(ctx, "glVertexArrayVertexAttribLOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_VertexAttribIPointer_no_error(GLuint index, GLint size, GLenum type,
         {
      const GLboolean normalized = GL_FALSE;
   const GLboolean integer = GL_TRUE;
            update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         /**
   * GL_EXT_gpu_shader4 / GL 3.0.
   * Set an integer-valued vertex attribute array.
   * Note that these arrays DO NOT alias the conventional GL vertex arrays
   * (position, normal, color, fog, texcoord, etc).
   */
   void GLAPIENTRY
   _mesa_VertexAttribIPointer(GLuint index, GLint size, GLenum type,
         {
      const GLboolean normalized = GL_FALSE;
   const GLboolean integer = GL_TRUE;
            GLenum format = GL_RGBA;
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribIPointer(index)");
               const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                  if (!validate_array_and_format(ctx, "glVertexAttribIPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexAttribLPointer_no_error(GLuint index, GLint size, GLenum type,
         {
               update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribIOffsetEXT(GLuint vaobj, GLuint buffer, GLuint index, GLint size,
         {
      const GLboolean normalized = GL_FALSE;
   const GLboolean integer = GL_TRUE;
   GET_CURRENT_CONTEXT(ctx);
            struct gl_vertex_array_object* vao;
            if (!_lookup_vao_and_vbo_dsa(ctx, vaobj, buffer, offset,
                        if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexArrayVertexAttribIOffsetEXT(index)");
               const GLbitfield legalTypes = (BYTE_BIT | UNSIGNED_BYTE_BIT |
                  if (!validate_array_and_format(ctx, "glVertexArrayVertexAttribIOffsetEXT",
                                    update_array(ctx, vao, vbo,
            }
         void GLAPIENTRY
   _mesa_VertexAttribLPointer(GLuint index, GLint size, GLenum type,
         {
               GLenum format = GL_RGBA;
   if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glVertexAttribLPointer(index)");
                        if (!validate_array_and_format(ctx, "glVertexAttribLPointer",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
      /**
   * Set the per-vertex edge flag enablement according to the "enable"
   * parameter. If "enable" is false, the zero-stride edge flag attribute value
   * will be used instead.
   *
   * This is used by VAOs, glBegin/End and display lists.
   */
   void
   _mesa_update_edgeflag_state_explicit(struct gl_context *ctx,
         {
      if (ctx->API != API_OPENGL_COMPAT)
            /* Edge flags take effect only if the polygon mode is not FILL, and they
   * determine whether a line or point is drawn with that polygon mode.
   */
   bool edgeflags_have_effect = ctx->Polygon.FrontMode != GL_FILL ||
                  if (per_vertex_enable != ctx->Array._PerVertexEdgeFlagsEnabled) {
               struct gl_program *vp = ctx->VertexProgram._Current;
   if (vp) {
      ctx->NewDriverState |= ST_NEW_VS_STATE |
                        /* If there are no per-vertex edge flags and the zero-stride edge flag is
   * false, all front and back points and lines generated by polygon mode
   * are not drawn.
   */
   bool polygon_mode_always_culls = edgeflags_have_effect &&
               if (polygon_mode_always_culls != ctx->Array._PolygonModeAlwaysCulls) {
      ctx->Array._PolygonModeAlwaysCulls = polygon_mode_always_culls;
         }
      /**
   * Set the edge flag state using the current VAO and the zero-stride
   * edge flag attribute value if per-vertex edge flags are disabled.
   */
   void
   _mesa_update_edgeflag_state_vao(struct gl_context *ctx)
   {
      _mesa_update_edgeflag_state_explicit(ctx,
            }
      void
   _mesa_enable_vertex_array_attribs(struct gl_context *ctx,
               {
               /* Only work on bits that are disabled */
   attrib_bits &= ~vao->Enabled;
   if (attrib_bits) {
      /* was disabled, now being enabled */
   vao->Enabled |= attrib_bits;
   vao->NonDefaultStateMask |= attrib_bits;
   ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
            /* Update the map mode if needed */
   if (attrib_bits & (VERT_BIT_POS|VERT_BIT_GENERIC0))
            if (attrib_bits & VERT_BIT_EDGEFLAG)
            vao->_EnabledWithMapMode =
         }
      static void
   enable_vertex_array_attrib(struct gl_context *ctx,
                     {
      if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index)", func);
                  }
         void GLAPIENTRY
   _mesa_EnableVertexAttribArray(GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   enable_vertex_array_attrib(ctx, ctx->Array.VAO, index,
      }
         void GLAPIENTRY
   _mesa_EnableVertexAttribArray_no_error(GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   _mesa_enable_vertex_array_attrib(ctx, ctx->Array.VAO,
      }
         void GLAPIENTRY
   _mesa_EnableVertexArrayAttrib(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by EnableVertexArrayAttrib
   *    and DisableVertexArrayAttrib if <vaobj> is not
   *    [compatibility profile: zero or] the name of an existing vertex
   *    array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glEnableVertexArrayAttrib");
   if (!vao)
               }
      void GLAPIENTRY
   _mesa_EnableVertexArrayAttribEXT(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object* vao = _mesa_lookup_vao_err(ctx, vaobj,
               if (!vao)
               }
         void GLAPIENTRY
   _mesa_EnableVertexArrayAttrib_no_error(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
      }
         void
   _mesa_disable_vertex_array_attribs(struct gl_context *ctx,
               {
               /* Only work on bits that are enabled */
   attrib_bits &= vao->Enabled;
   if (attrib_bits) {
      /* was enabled, now being disabled */
   vao->Enabled &= ~attrib_bits;
   ctx->NewDriverState |= ST_NEW_VERTEX_ARRAYS;
            /* Update the map mode if needed */
   if (attrib_bits & (VERT_BIT_POS|VERT_BIT_GENERIC0))
            if (attrib_bits & VERT_BIT_EDGEFLAG)
            vao->_EnabledWithMapMode =
         }
         void GLAPIENTRY
   _mesa_DisableVertexAttribArray(GLuint index)
   {
               if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDisableVertexAttribArray(index)");
               const gl_vert_attrib attrib = VERT_ATTRIB_GENERIC(index);
      }
         void GLAPIENTRY
   _mesa_DisableVertexAttribArray_no_error(GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   const gl_vert_attrib attrib = VERT_ATTRIB_GENERIC(index);
      }
         void GLAPIENTRY
   _mesa_DisableVertexArrayAttrib(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by EnableVertexArrayAttrib
   *    and DisableVertexArrayAttrib if <vaobj> is not
   *    [compatibility profile: zero or] the name of an existing vertex
   *    array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glDisableVertexArrayAttrib");
   if (!vao)
            if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDisableVertexArrayAttrib(index)");
               const gl_vert_attrib attrib = VERT_ATTRIB_GENERIC(index);
      }
      void GLAPIENTRY
   _mesa_DisableVertexArrayAttribEXT(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object* vao = _mesa_lookup_vao_err(ctx, vaobj,
               if (!vao)
            if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glDisableVertexArrayAttrib(index)");
               const gl_vert_attrib attrib = VERT_ATTRIB_GENERIC(index);
      }
         void GLAPIENTRY
   _mesa_DisableVertexArrayAttrib_no_error(GLuint vaobj, GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
   const gl_vert_attrib attrib = VERT_ATTRIB_GENERIC(index);
      }
         /**
   * Return info for a vertex attribute array (no alias with legacy
   * vertex attributes (pos, normal, color, etc)).  This function does
   * not handle the 4-element GL_CURRENT_VERTEX_ATTRIB_ARB query.
   */
   static GLuint
   get_vertex_array_attrib(struct gl_context *ctx,
                     {
      const struct gl_array_attributes *array;
            if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "%s(index=%u)", caller, index);
                                 switch (pname) {
   case GL_VERTEX_ATTRIB_ARRAY_ENABLED_ARB:
         case GL_VERTEX_ATTRIB_ARRAY_SIZE_ARB:
         case GL_VERTEX_ATTRIB_ARRAY_STRIDE_ARB:
         case GL_VERTEX_ATTRIB_ARRAY_TYPE_ARB:
         case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED_ARB:
         case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB:
      buf = vao->BufferBinding[array->BufferBindingIndex].BufferObj;
      case GL_VERTEX_ATTRIB_ARRAY_INTEGER:
      if ((_mesa_is_desktop_gl(ctx)
      && (ctx->Version >= 30 || ctx->Extensions.EXT_gpu_shader4))
   || _mesa_is_gles3(ctx)) {
      }
      case GL_VERTEX_ATTRIB_ARRAY_LONG:
      if (_mesa_is_desktop_gl(ctx)) {
         }
      case GL_VERTEX_ATTRIB_ARRAY_DIVISOR_ARB:
      if (_mesa_has_ARB_instanced_arrays(ctx) ||
      _mesa_has_EXT_instanced_arrays(ctx)) {
      }
      case GL_VERTEX_ATTRIB_BINDING:
      if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles31(ctx)) {
         }
      case GL_VERTEX_ATTRIB_RELATIVE_OFFSET:
      if (_mesa_is_desktop_gl(ctx) || _mesa_is_gles31(ctx)) {
         }
      default:
               error:
      _mesa_error(ctx, GL_INVALID_ENUM, "%s(pname=0x%x)", caller, pname);
      }
         static const GLfloat *
   get_current_attrib(struct gl_context *ctx, GLuint index, const char *function)
   {
      if (index == 0) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(index==0)", function);
   return NULL;
            }
   else if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
         "%s(index>=GL_MAX_VERTEX_ATTRIBS)", function);
                  assert(VERT_ATTRIB_GENERIC(index) <
            FLUSH_CURRENT(ctx, 0);
      }
      void GLAPIENTRY
   _mesa_GetVertexAttribfv(GLuint index, GLenum pname, GLfloat *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribfv");
   if (v != NULL) {
            }
   else {
      params[0] = (GLfloat) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
         void GLAPIENTRY
   _mesa_GetVertexAttribdv(GLuint index, GLenum pname, GLdouble *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribdv");
   if (v != NULL) {
      params[0] = (GLdouble) v[0];
   params[1] = (GLdouble) v[1];
   params[2] = (GLdouble) v[2];
         }
   else {
      params[0] = (GLdouble) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
      void GLAPIENTRY
   _mesa_GetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLdouble *v =
      (const GLdouble *)get_current_attrib(ctx, index,
      if (v != NULL) {
      params[0] = v[0];
   params[1] = v[1];
   params[2] = v[2];
         }
   else {
      params[0] = (GLdouble) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
      void GLAPIENTRY
   _mesa_GetVertexAttribiv(GLuint index, GLenum pname, GLint *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLfloat *v = get_current_attrib(ctx, index, "glGetVertexAttribiv");
   if (v != NULL) {
      /* XXX should floats in[0,1] be scaled to full int range? */
   params[0] = (GLint) v[0];
   params[1] = (GLint) v[1];
   params[2] = (GLint) v[2];
         }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
      void GLAPIENTRY
   _mesa_GetVertexAttribLui64vARB(GLuint index, GLenum pname, GLuint64EXT *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      const GLuint64 *v =
      (const GLuint64 *)get_current_attrib(ctx, index,
      if (v != NULL) {
      params[0] = v[0];
   params[1] = v[1];
   params[2] = v[2];
         }
   else {
      params[0] = (GLuint64) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
         /** GL 3.0 */
   void GLAPIENTRY
   _mesa_GetVertexAttribIiv(GLuint index, GLenum pname, GLint *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      get_current_attrib(ctx, index, "glGetVertexAttribIiv");
         if (v != NULL) {
            }
   else {
      params[0] = (GLint) get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
         /** GL 3.0 */
   void GLAPIENTRY
   _mesa_GetVertexAttribIuiv(GLuint index, GLenum pname, GLuint *params)
   {
               if (pname == GL_CURRENT_VERTEX_ATTRIB_ARB) {
      get_current_attrib(ctx, index, "glGetVertexAttribIuiv");
         if (v != NULL) {
            }
   else {
      params[0] = get_vertex_array_attrib(ctx, ctx->Array.VAO,
               }
         void GLAPIENTRY
   _mesa_GetVertexAttribPointerv(GLuint index, GLenum pname, GLvoid **pointer)
   {
               if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetVertexAttribPointerARB(index)");
               if (pname != GL_VERTEX_ATTRIB_ARRAY_POINTER_ARB) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetVertexAttribPointerARB(pname)");
               assert(VERT_ATTRIB_GENERIC(index) <
            *pointer = (GLvoid *)
      }
         /** ARB_direct_state_access */
   void GLAPIENTRY
   _mesa_GetVertexArrayIndexediv(GLuint vaobj, GLuint index,
         {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object *vao;
            /* The ARB_direct_state_access specification says:
   *
   *    "An INVALID_OPERATION error is generated if <vaobj> is not
   *     [compatibility profile: zero or] the name of an existing
   *     vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glGetVertexArrayIndexediv");
   if (!vao)
            /* The ARB_direct_state_access specification says:
   *
   *    "For GetVertexArrayIndexediv, <pname> must be one of
   *     VERTEX_ATTRIB_ARRAY_ENABLED, VERTEX_ATTRIB_ARRAY_SIZE,
   *     VERTEX_ATTRIB_ARRAY_STRIDE, VERTEX_ATTRIB_ARRAY_TYPE,
   *     VERTEX_ATTRIB_ARRAY_NORMALIZED, VERTEX_ATTRIB_ARRAY_INTEGER,
   *     VERTEX_ATTRIB_ARRAY_LONG, VERTEX_ATTRIB_ARRAY_DIVISOR, or
   *     VERTEX_ATTRIB_RELATIVE_OFFSET."
   *
   * and:
   *
   *    "Add GetVertexArrayIndexediv in 'Get Command' for
   *     VERTEX_ATTRIB_ARRAY_BUFFER_BINDING
   *     VERTEX_ATTRIB_BINDING,
   *     VERTEX_ATTRIB_RELATIVE_OFFSET,
   *     VERTEX_BINDING_OFFSET, and
   *     VERTEX_BINDING_STRIDE states"
   *
   * The only parameter name common to both lists is
   * VERTEX_ATTRIB_RELATIVE_OFFSET.  Also note that VERTEX_BINDING_BUFFER
   * and VERTEX_BINDING_DIVISOR are missing from both lists.  It seems
   * pretty clear however that the intent is that it should be possible
   * to query all vertex attrib and binding states that can be set with
   * a DSA function.
   */
   switch (pname) {
   case GL_VERTEX_BINDING_OFFSET:
      params[0] = vao->BufferBinding[VERT_ATTRIB_GENERIC(index)].Offset;
      case GL_VERTEX_BINDING_STRIDE:
      params[0] = vao->BufferBinding[VERT_ATTRIB_GENERIC(index)].Stride;
      case GL_VERTEX_BINDING_DIVISOR:
      params[0] = vao->BufferBinding[VERT_ATTRIB_GENERIC(index)].InstanceDivisor;
      case GL_VERTEX_BINDING_BUFFER:
      buf = vao->BufferBinding[VERT_ATTRIB_GENERIC(index)].BufferObj;
   params[0] = buf ? buf->Name : 0;
      default:
      params[0] = get_vertex_array_attrib(ctx, vao, index, pname,
               }
         void GLAPIENTRY
   _mesa_GetVertexArrayIndexed64iv(GLuint vaobj, GLuint index,
         {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *    "An INVALID_OPERATION error is generated if <vaobj> is not
   *     [compatibility profile: zero or] the name of an existing
   *     vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glGetVertexArrayIndexed64iv");
   if (!vao)
            /* The ARB_direct_state_access specification says:
   *
   *    "For GetVertexArrayIndexed64iv, <pname> must be
   *     VERTEX_BINDING_OFFSET."
   *
   * and:
   *
   *    "An INVALID_ENUM error is generated if <pname> is not one of
   *     the valid values listed above for the corresponding command."
   */
   if (pname != GL_VERTEX_BINDING_OFFSET) {
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetVertexArrayIndexed64iv("
                     /* The ARB_direct_state_access specification says:
   *
   *    "An INVALID_VALUE error is generated if <index> is greater than
   *     or equal to the value of MAX_VERTEX_ATTRIBS."
   *
   * Since the index refers to a buffer binding in this case, the intended
   * limit must be MAX_VERTEX_ATTRIB_BINDINGS.  Both limits are currently
   * required to be the same, so in practice this doesn't matter.
   */
   if (index >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetVertexArrayIndexed64iv(index"
                              }
         void GLAPIENTRY
   _mesa_VertexPointerEXT(GLint size, GLenum type, GLsizei stride,
         {
      (void) count;
      }
         void GLAPIENTRY
   _mesa_NormalPointerEXT(GLenum type, GLsizei stride, GLsizei count,
         {
      (void) count;
      }
         void GLAPIENTRY
   _mesa_ColorPointerEXT(GLint size, GLenum type, GLsizei stride, GLsizei count,
         {
      (void) count;
      }
         void GLAPIENTRY
   _mesa_IndexPointerEXT(GLenum type, GLsizei stride, GLsizei count,
         {
      (void) count;
      }
         void GLAPIENTRY
   _mesa_TexCoordPointerEXT(GLint size, GLenum type, GLsizei stride,
         {
      (void) count;
      }
         void GLAPIENTRY
   _mesa_MultiTexCoordPointerEXT(GLenum texunit, GLint size, GLenum type,
         {
      GET_CURRENT_CONTEXT(ctx);
   const GLint sizeMin = 1;
            GLenum format = GL_RGBA;
   const GLbitfield legalTypes = (SHORT_BIT | INT_BIT |
                        if (!validate_array_and_format(ctx, "glMultiTexCoordPointerEXT",
                                    update_array(ctx, ctx->Array.VAO, ctx->Array.ArrayBufferObj,
            }
         void GLAPIENTRY
   _mesa_EdgeFlagPointerEXT(GLsizei stride, GLsizei count, const GLboolean *ptr)
   {
      (void) count;
      }
         bool
   _mesa_get_interleaved_layout(GLenum format,
         {
      int f = sizeof(GLfloat);
                     switch (format) {
      case GL_V2F:
      layout->vcomps = 2;
   layout->defstride = 2 * f;
      case GL_V3F:
      layout->vcomps = 3;
   layout->defstride = 3 * f;
      case GL_C4UB_V2F:
      layout->cflag = true;
   layout->ccomps = 4;  layout->vcomps = 2;
   layout->ctype = GL_UNSIGNED_BYTE;
   layout->voffset = c;
   layout->defstride = c + 2 * f;
      case GL_C4UB_V3F:
      layout->cflag = true;
   layout->ccomps = 4;  layout->vcomps = 3;
   layout->ctype = GL_UNSIGNED_BYTE;
   layout->voffset = c;
   layout->defstride = c + 3 * f;
      case GL_C3F_V3F:
      layout->cflag = true;
   layout->ccomps = 3;  layout->vcomps = 3;
   layout->ctype = GL_FLOAT;
   layout->voffset = 3 * f;
   layout->defstride = 6 * f;
      case GL_N3F_V3F:
      layout->nflag = true;
   layout->vcomps = 3;
   layout->voffset = 3 * f;
   layout->defstride = 6 * f;
      case GL_C4F_N3F_V3F:
      layout->cflag = true;  layout->nflag = true;
   layout->ccomps = 4;  layout->vcomps = 3;
   layout->ctype = GL_FLOAT;
   layout->noffset = 4 * f;
   layout->voffset = 7 * f;
   layout->defstride = 10 * f;
      case GL_T2F_V3F:
      layout->tflag = true;
   layout->tcomps = 2;  layout->vcomps = 3;
   layout->voffset = 2 * f;
   layout->defstride = 5 * f;
      case GL_T4F_V4F:
      layout->tflag = true;
   layout->tcomps = 4;  layout->vcomps = 4;
   layout->voffset = 4 * f;
   layout->defstride = 8 * f;
      case GL_T2F_C4UB_V3F:
      layout->tflag = true;  layout->cflag = true;
   layout->tcomps = 2;  layout->ccomps = 4;  layout->vcomps = 3;
   layout->ctype = GL_UNSIGNED_BYTE;
   layout->coffset = 2 * f;
   layout->voffset = c + 2 * f;
   layout->defstride = c + 5 * f;
      case GL_T2F_C3F_V3F:
      layout->tflag = true;  layout->cflag = true;
   layout->tcomps = 2;  layout->ccomps = 3;  layout->vcomps = 3;
   layout->ctype = GL_FLOAT;
   layout->coffset = 2 * f;
   layout->voffset = 5 * f;
   layout->defstride = 8 * f;
      case GL_T2F_N3F_V3F:
      layout->tflag = true;    layout->nflag = true;
   layout->tcomps = 2;  layout->vcomps = 3;
   layout->noffset = 2 * f;
   layout->voffset = 5 * f;
   layout->defstride = 8 * f;
      case GL_T2F_C4F_N3F_V3F:
      layout->tflag = true;  layout->cflag = true;  layout->nflag = true;
   layout->tcomps = 2;  layout->ccomps = 4;  layout->vcomps = 3;
   layout->ctype = GL_FLOAT;
   layout->coffset = 2 * f;
   layout->noffset = 6 * f;
   layout->voffset = 9 * f;
   layout->defstride = 12 * f;
      case GL_T4F_C4F_N3F_V4F:
      layout->tflag = true;  layout->cflag = true;  layout->nflag = true;
   layout->tcomps = 4;  layout->ccomps = 4;  layout->vcomps = 4;
   layout->ctype = GL_FLOAT;
   layout->coffset = 4 * f;
   layout->noffset = 8 * f;
   layout->voffset = 11 * f;
   layout->defstride = 15 * f;
      default:
      }
      }
      void GLAPIENTRY
   _mesa_InterleavedArrays(GLenum format, GLsizei stride, const GLvoid *pointer)
   {
      GET_CURRENT_CONTEXT(ctx);
            if (stride < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glInterleavedArrays(stride)" );
               if (!_mesa_get_interleaved_layout(format, &layout)) {
      _mesa_error( ctx, GL_INVALID_ENUM, "glInterleavedArrays(format)" );
               if (stride==0) {
                  _mesa_DisableClientState( GL_EDGE_FLAG_ARRAY );
   _mesa_DisableClientState( GL_INDEX_ARRAY );
            /* Texcoords */
   if (layout.tflag) {
      _mesa_EnableClientState( GL_TEXTURE_COORD_ARRAY );
   _mesa_TexCoordPointer( layout.tcomps, GL_FLOAT, stride,
      }
   else {
                  /* Color */
   if (layout.cflag) {
      _mesa_EnableClientState( GL_COLOR_ARRAY );
      (GLubyte *) pointer + layout.coffset );
   }
   else {
                     /* Normals */
   if (layout.nflag) {
      _mesa_EnableClientState( GL_NORMAL_ARRAY );
      }
   else {
                  /* Vertices */
   _mesa_EnableClientState( GL_VERTEX_ARRAY );
   _mesa_VertexPointer( layout.vcomps, GL_FLOAT, stride,
      }
         void GLAPIENTRY
   _mesa_LockArraysEXT(GLint first, GLsizei count)
   {
               if (MESA_VERBOSE & VERBOSE_API)
            if (first < 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(first)" );
      }
   if (count <= 0) {
      _mesa_error( ctx, GL_INVALID_VALUE, "glLockArraysEXT(count)" );
      }
   if (ctx->Array.LockCount != 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glLockArraysEXT(reentry)" );
               ctx->Array.LockFirst = first;
      }
         void GLAPIENTRY
   _mesa_UnlockArraysEXT( void )
   {
               if (MESA_VERBOSE & VERBOSE_API)
            if (ctx->Array.LockCount == 0) {
      _mesa_error( ctx, GL_INVALID_OPERATION, "glUnlockArraysEXT(reexit)" );
               ctx->Array.LockFirst = 0;
      }
         static void
   primitive_restart_index(struct gl_context *ctx, GLuint index)
   {
      ctx->Array.RestartIndex = index;
      }
         /**
   * GL_NV_primitive_restart and GL 3.1
   */
   void GLAPIENTRY
   _mesa_PrimitiveRestartIndex_no_error(GLuint index)
   {
      GET_CURRENT_CONTEXT(ctx);
      }
         void GLAPIENTRY
   _mesa_PrimitiveRestartIndex(GLuint index)
   {
               if (!ctx->Extensions.NV_primitive_restart && ctx->Version < 31) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glPrimitiveRestartIndexNV()");
                  }
         void GLAPIENTRY
   _mesa_VertexAttribDivisor_no_error(GLuint index, GLuint divisor)
   {
               const gl_vert_attrib genericIndex = VERT_ATTRIB_GENERIC(index);
                     /* The ARB_vertex_attrib_binding spec says:
   *
   *    "The command
   *
   *       void VertexAttribDivisor(uint index, uint divisor);
   *
   *     is equivalent to (assuming no errors are generated):
   *
   *       VertexAttribBinding(index, index);
   *       VertexBindingDivisor(index, divisor);"
   */
   _mesa_vertex_attrib_binding(ctx, vao, genericIndex, genericIndex);
      }
         /**
   * See GL_ARB_instanced_arrays.
   * Note that the instance divisor only applies to generic arrays, not
   * the legacy vertex arrays.
   */
   void GLAPIENTRY
   _mesa_VertexAttribDivisor(GLuint index, GLuint divisor)
   {
               const gl_vert_attrib genericIndex = VERT_ATTRIB_GENERIC(index);
            if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexAttribDivisor()");
               if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                              /* The ARB_vertex_attrib_binding spec says:
   *
   *    "The command
   *
   *       void VertexAttribDivisor(uint index, uint divisor);
   *
   *     is equivalent to (assuming no errors are generated):
   *
   *       VertexAttribBinding(index, index);
   *       VertexBindingDivisor(index, divisor);"
   */
   _mesa_vertex_attrib_binding(ctx, vao, genericIndex, genericIndex);
      }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribDivisorEXT(GLuint vaobj, GLuint index, GLuint divisor)
   {
               const gl_vert_attrib genericIndex = VERT_ATTRIB_GENERIC(index);
   struct gl_vertex_array_object * vao;
   /* The ARB_instanced_arrays spec says:
   *
   *     "The vertex array object named by vaobj must
   *     be generated by GenVertexArrays (and not since deleted);
   *     otherwise an INVALID_OPERATION error is generated."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj,
               if (!vao)
            if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "glVertexArrayVertexAttribDivisorEXT()");
               if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                              /* The ARB_vertex_attrib_binding spec says:
   *
   *    "The command
   *
   *       void VertexAttribDivisor(uint index, uint divisor);
   *
   *     is equivalent to (assuming no errors are generated):
   *
   *       VertexAttribBinding(index, index);
   *       VertexBindingDivisor(index, divisor);"
   */
   _mesa_vertex_attrib_binding(ctx, vao, genericIndex, genericIndex);
      }
            static ALWAYS_INLINE void
   vertex_array_vertex_buffer(struct gl_context *ctx,
                     {
      struct gl_buffer_object *vbo;
   struct gl_buffer_object *current_buf =
            if (current_buf && buffer == current_buf->Name) {
         } else if (buffer != 0) {
               if (!no_error && !vbo && _mesa_is_gles31(ctx)) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s(non-gen name)", func);
      }
   /* From the GL_ARB_vertex_attrib_array spec:
   *
   *   "[Core profile only:]
   *    An INVALID_OPERATION error is generated if buffer is not zero or a
   *    name returned from a previous call to GenBuffers, or if such a name
   *    has since been deleted with DeleteBuffers.
   *
   * Otherwise, we fall back to the same compat profile behavior as other
   * object references (automatically gen it).
   */
   if (!_mesa_handle_bind_buffer_gen(ctx, buffer, &vbo, func, no_error))
      } else {
      /* The ARB_vertex_attrib_binding spec says:
   *
   *    "If <buffer> is zero, any buffer object attached to this
   *     bindpoint is detached."
   */
               _mesa_bind_vertex_buffer(ctx, vao, VERT_ATTRIB_GENERIC(bindingIndex),
      }
         /**
   * GL_ARB_vertex_attrib_binding
   */
   static void
   vertex_array_vertex_buffer_err(struct gl_context *ctx,
                           {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_VALUE error is generated if <bindingindex> is greater than
   *     the value of MAX_VERTEX_ATTRIB_BINDINGS."
   */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(bindingindex=%u > "
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "The error INVALID_VALUE is generated if <stride> or <offset>
   *     are negative."
   */
   if (offset < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           if (stride < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                     if (((_mesa_is_desktop_gl(ctx) && ctx->Version >= 44) || _mesa_is_gles31(ctx)) &&
      stride > ctx->Const.MaxVertexAttribStride) {
   _mesa_error(ctx, GL_INVALID_VALUE, "%s(stride=%d > "
                     vertex_array_vertex_buffer(ctx, vao, bindingIndex, buffer, offset,
      }
         void GLAPIENTRY
   _mesa_BindVertexBuffer_no_error(GLuint bindingIndex, GLuint buffer,
         {
      GET_CURRENT_CONTEXT(ctx);
   vertex_array_vertex_buffer(ctx, ctx->Array.VAO, bindingIndex,
            }
         void GLAPIENTRY
   _mesa_BindVertexBuffer(GLuint bindingIndex, GLuint buffer, GLintptr offset,
         {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_OPERATION error is generated if no vertex array object
   *     is bound."
   */
   if ((_mesa_is_desktop_gl_core(ctx) || _mesa_is_gles31(ctx)) &&
      ctx->Array.VAO == ctx->Array.DefaultVAO) {
   _mesa_error(ctx, GL_INVALID_OPERATION,
                     vertex_array_vertex_buffer_err(ctx, ctx->Array.VAO, bindingIndex,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexBuffer_no_error(GLuint vaobj, GLuint bindingIndex,
               {
               struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
   vertex_array_vertex_buffer(ctx, vao, bindingIndex, buffer, offset,
      }
         void GLAPIENTRY
   _mesa_VertexArrayVertexBuffer(GLuint vaobj, GLuint bindingIndex, GLuint buffer,
         {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by VertexArrayVertexBuffer
   *    if <vaobj> is not [compatibility profile: zero or] the name of an
   *    existing vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glVertexArrayVertexBuffer");
   if (!vao)
            vertex_array_vertex_buffer_err(ctx, vao, bindingIndex, buffer, offset,
      }
         void GLAPIENTRY
   _mesa_VertexArrayBindVertexBufferEXT(GLuint vaobj, GLuint bindingIndex, GLuint buffer,
         {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object *vao;
   vao = _mesa_lookup_vao_err(ctx, vaobj, true, "glVertexArrayBindVertexBufferEXT");
   if (!vao)
            vertex_array_vertex_buffer_err(ctx, vao, bindingIndex, buffer, offset,
      }
         static ALWAYS_INLINE void
   vertex_array_vertex_buffers(struct gl_context *ctx,
                           {
               if (!buffers) {
      /**
   * The ARB_multi_bind spec says:
   *
   *    "If <buffers> is NULL, each affected vertex buffer binding point
   *     from <first> through <first>+<count>-1 will be reset to have no
   *     bound buffer object.  In this case, the offsets and strides
   *     associated with the binding points are set to default values,
   *     ignoring <offsets> and <strides>."
   */
   for (i = 0; i < count; i++)
                              /* Note that the error semantics for multi-bind commands differ from
   * those of other GL commands.
   *
   * The Issues section in the ARB_multi_bind spec says:
   *
   *    "(11) Typically, OpenGL specifies that if an error is generated by
   *          a command, that command has no effect.  This is somewhat
   *          unfortunate for multi-bind commands, because it would require
   *          a first pass to scan the entire list of bound objects for
   *          errors and then a second pass to actually perform the
   *          bindings.  Should we have different error semantics?
   *
   *       RESOLVED:  Yes.  In this specification, when the parameters for
   *       one of the <count> binding points are invalid, that binding
   *       point is not updated and an error will be generated.  However,
   *       other binding points in the same command will be updated if
   *       their parameters are valid and no other error occurs."
            _mesa_HashLockMaybeLocked(ctx->Shared->BufferObjects,
            for (i = 0; i < count; i++) {
               if (!no_error) {
      /* The ARB_multi_bind spec says:
   *
   *    "An INVALID_VALUE error is generated if any value in
   *     <offsets> or <strides> is negative (per binding)."
   */
   if (offsets[i] < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           if (strides[i] < 0) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           if (_mesa_is_desktop_gl(ctx) && ctx->Version >= 44 &&
      strides[i] > ctx->Const.MaxVertexAttribStride) {
   _mesa_error(ctx, GL_INVALID_VALUE,
                              if (buffers[i]) {
                     if (buffers[i] == 0)
         else if (binding->BufferObj && binding->BufferObj->Name == buffers[i])
         else {
      bool error;
   vbo = _mesa_multi_bind_lookup_bufferobj(ctx, buffers, i, func,
         if (error)
         } else {
                  _mesa_bind_vertex_buffer(ctx, vao, VERT_ATTRIB_GENERIC(first + i),
               _mesa_HashUnlockMaybeLocked(ctx->Shared->BufferObjects,
      }
         static void
   vertex_array_vertex_buffers_err(struct gl_context *ctx,
                           {
               /* The ARB_multi_bind spec says:
   *
   *    "An INVALID_OPERATION error is generated if <first> + <count>
   *     is greater than the value of MAX_VERTEX_ATTRIB_BINDINGS."
   */
   if (first + count > ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_OPERATION,
               "%s(first=%u + count=%d > the value of "
               vertex_array_vertex_buffers(ctx, vao, first, count, buffers, offsets,
      }
         void GLAPIENTRY
   _mesa_BindVertexBuffers_no_error(GLuint first, GLsizei count,
               {
               vertex_array_vertex_buffers(ctx, ctx->Array.VAO, first, count,
            }
         void GLAPIENTRY
   _mesa_BindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers,
         {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_OPERATION error is generated if no
   *     vertex array object is bound."
   */
   if (_mesa_is_desktop_gl_core(ctx) &&
      ctx->Array.VAO == ctx->Array.DefaultVAO) {
   _mesa_error(ctx, GL_INVALID_OPERATION,
                     vertex_array_vertex_buffers_err(ctx, ctx->Array.VAO, first, count,
            }
         void
   _mesa_InternalBindVertexBuffers(struct gl_context *ctx,
               {
      struct gl_vertex_array_object *vao = ctx->Array.VAO;
            while (buffer_mask) {
      unsigned i = u_bit_scan(&buffer_mask);
            /* The buffer reference is passed to _mesa_bind_vertex_buffer. */
   _mesa_bind_vertex_buffer(ctx, vao, i, buf, buffers[param_index].offset,
               }
         void GLAPIENTRY
   _mesa_VertexArrayVertexBuffers_no_error(GLuint vaobj, GLuint first,
                     {
               struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
   vertex_array_vertex_buffers(ctx, vao, first, count,
            }
         void GLAPIENTRY
   _mesa_VertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count,
               {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by VertexArrayVertexBuffer
   *    if <vaobj> is not [compatibility profile: zero or] the name of an
   *    existing vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glVertexArrayVertexBuffers");
   if (!vao)
            vertex_array_vertex_buffers_err(ctx, vao, first, count,
            }
         static void
   vertex_attrib_format(GLuint attribIndex, GLint size, GLenum type,
                           {
      GET_CURRENT_CONTEXT(ctx);
                     if (!_mesa_is_no_error_enabled(ctx)) {
      /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_OPERATION error is generated under any of the
   *    following conditions:
   *     - if no vertex array object is currently bound (see section
   *       2.10);
   *     - ..."
   *
   * This error condition only applies to VertexAttribFormat and
   * VertexAttribIFormat in the extension spec, but we assume that this
   * is an oversight.  In the OpenGL 4.3 (Core Profile) spec, it applies
   * to all three functions.
   */
   if ((_mesa_is_desktop_gl_core(ctx) || _mesa_is_gles31(ctx)) &&
      ctx->Array.VAO == ctx->Array.DefaultVAO) {
   _mesa_error(ctx, GL_INVALID_OPERATION,
                     /* The ARB_vertex_attrib_binding spec says:
   *
   *   "The error INVALID_VALUE is generated if index is greater than or
   *   equal to the value of MAX_VERTEX_ATTRIBS."
   */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(attribindex=%u > "
               if (!validate_array_format(ctx, func, ctx->Array.VAO,
                                             _mesa_update_array_format(ctx, ctx->Array.VAO,
                  }
         void GLAPIENTRY
   _mesa_VertexAttribFormat(GLuint attribIndex, GLint size, GLenum type,
         {
      vertex_attrib_format(attribIndex, size, type, normalized,
                  }
         void GLAPIENTRY
   _mesa_VertexAttribIFormat(GLuint attribIndex, GLint size, GLenum type,
         {
      vertex_attrib_format(attribIndex, size, type, GL_FALSE,
            }
         void GLAPIENTRY
   _mesa_VertexAttribLFormat(GLuint attribIndex, GLint size, GLenum type,
         {
      vertex_attrib_format(attribIndex, size, type, GL_FALSE, GL_FALSE,
            }
         static void
   vertex_array_attrib_format(GLuint vaobj, bool isExtDsa, GLuint attribIndex,
                           {
      GET_CURRENT_CONTEXT(ctx);
                              if (_mesa_is_no_error_enabled(ctx)) {
      vao = _mesa_lookup_vao(ctx, vaobj);
   if (!vao)
      } else {
      vao = _mesa_lookup_vao_err(ctx, vaobj, isExtDsa, func);
   if (!vao)
            /* The ARB_vertex_attrib_binding spec says:
   *
   *   "The error INVALID_VALUE is generated if index is greater than or
   *   equal to the value of MAX_VERTEX_ATTRIBS."
   */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
                           if (!validate_array_format(ctx, func, vao,
                                             _mesa_update_array_format(ctx, vao, VERT_ATTRIB_GENERIC(attribIndex), size,
            }
         void GLAPIENTRY
   _mesa_VertexArrayAttribFormat(GLuint vaobj, GLuint attribIndex, GLint size,
               {
      vertex_array_attrib_format(vaobj, false, attribIndex, size, type, normalized,
                  }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribFormatEXT(GLuint vaobj, GLuint attribIndex, GLint size,
               {
      vertex_array_attrib_format(vaobj, true, attribIndex, size, type, normalized,
                  }
         void GLAPIENTRY
   _mesa_VertexArrayAttribIFormat(GLuint vaobj, GLuint attribIndex,
               {
      vertex_array_attrib_format(vaobj, false, attribIndex, size, type, GL_FALSE,
                  }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribIFormatEXT(GLuint vaobj, GLuint attribIndex,
               {
      vertex_array_attrib_format(vaobj, true, attribIndex, size, type, GL_FALSE,
                  }
         void GLAPIENTRY
   _mesa_VertexArrayAttribLFormat(GLuint vaobj, GLuint attribIndex,
               {
      vertex_array_attrib_format(vaobj, false, attribIndex, size, type, GL_FALSE,
                  }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribLFormatEXT(GLuint vaobj, GLuint attribIndex,
               {
      vertex_array_attrib_format(vaobj, true, attribIndex, size, type, GL_FALSE,
                  }
         static void
   vertex_array_attrib_binding(struct gl_context *ctx,
                     {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "<attribindex> must be less than the value of MAX_VERTEX_ATTRIBS and
   *     <bindingindex> must be less than the value of
   *     MAX_VERTEX_ATTRIB_BINDINGS, otherwise the error INVALID_VALUE
   *     is generated."
   */
   if (attribIndex >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(attribindex=%u >= "
               if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(bindingindex=%u >= "
                        _mesa_vertex_attrib_binding(ctx, vao,
            }
         void GLAPIENTRY
   _mesa_VertexAttribBinding_no_error(GLuint attribIndex, GLuint bindingIndex)
   {
      GET_CURRENT_CONTEXT(ctx);
   _mesa_vertex_attrib_binding(ctx, ctx->Array.VAO,
            }
         void GLAPIENTRY
   _mesa_VertexAttribBinding(GLuint attribIndex, GLuint bindingIndex)
   {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_OPERATION error is generated if no vertex array object
   *     is bound."
   */
   if ((_mesa_is_desktop_gl_core(ctx) || _mesa_is_gles31(ctx)) &&
      ctx->Array.VAO == ctx->Array.DefaultVAO) {
   _mesa_error(ctx, GL_INVALID_OPERATION,
                     vertex_array_attrib_binding(ctx, ctx->Array.VAO,
            }
         void GLAPIENTRY
   _mesa_VertexArrayAttribBinding_no_error(GLuint vaobj, GLuint attribIndex,
         {
               struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
   _mesa_vertex_attrib_binding(ctx, vao,
            }
         void GLAPIENTRY
   _mesa_VertexArrayAttribBinding(GLuint vaobj, GLuint attribIndex, GLuint bindingIndex)
   {
      GET_CURRENT_CONTEXT(ctx);
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by VertexArrayAttribBinding
   *    if <vaobj> is not [compatibility profile: zero or] the name of an
   *    existing vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glVertexArrayAttribBinding");
   if (!vao)
            vertex_array_attrib_binding(ctx, vao, attribIndex, bindingIndex,
      }
         void GLAPIENTRY
   _mesa_VertexArrayVertexAttribBindingEXT(GLuint vaobj, GLuint attribIndex, GLuint bindingIndex)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object *vao;
   vao = _mesa_lookup_vao_err(ctx, vaobj, true, "glVertexArrayVertexAttribBindingEXT");
   if (!vao)
            vertex_array_attrib_binding(ctx, vao, attribIndex, bindingIndex,
      }
         static void
   vertex_array_binding_divisor(struct gl_context *ctx,
                     {
               if (!ctx->Extensions.ARB_instanced_arrays) {
      _mesa_error(ctx, GL_INVALID_OPERATION, "%s()", func);
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_VALUE error is generated if <bindingindex> is greater
   *     than or equal to the value of MAX_VERTEX_ATTRIB_BINDINGS."
   */
   if (bindingIndex >= ctx->Const.MaxVertexAttribBindings) {
      _mesa_error(ctx, GL_INVALID_VALUE,
               "%s(bindingindex=%u > "
                  }
         void GLAPIENTRY
   _mesa_VertexBindingDivisor_no_error(GLuint bindingIndex, GLuint divisor)
   {
      GET_CURRENT_CONTEXT(ctx);
   vertex_binding_divisor(ctx, ctx->Array.VAO,
      }
         void GLAPIENTRY
   _mesa_VertexBindingDivisor(GLuint bindingIndex, GLuint divisor)
   {
               /* The ARB_vertex_attrib_binding spec says:
   *
   *    "An INVALID_OPERATION error is generated if no vertex array object
   *     is bound."
   */
   if ((_mesa_is_desktop_gl_core(ctx) || _mesa_is_gles31(ctx)) &&
      ctx->Array.VAO == ctx->Array.DefaultVAO) {
   _mesa_error(ctx, GL_INVALID_OPERATION,
                     vertex_array_binding_divisor(ctx, ctx->Array.VAO,
            }
         void GLAPIENTRY
   _mesa_VertexArrayBindingDivisor_no_error(GLuint vaobj, GLuint bindingIndex,
         {
               struct gl_vertex_array_object *vao = _mesa_lookup_vao(ctx, vaobj);
      }
         void GLAPIENTRY
   _mesa_VertexArrayBindingDivisor(GLuint vaobj, GLuint bindingIndex,
         {
      struct gl_vertex_array_object *vao;
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by VertexArrayBindingDivisor
   *    if <vaobj> is not [compatibility profile: zero or] the name of an
   *    existing vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, false, "glVertexArrayBindingDivisor");
   if (!vao)
            vertex_array_binding_divisor(ctx, vao, bindingIndex, divisor,
      }
         void GLAPIENTRY
   _mesa_VertexArrayVertexBindingDivisorEXT(GLuint vaobj, GLuint bindingIndex,
         {
      struct gl_vertex_array_object *vao;
            /* The ARB_direct_state_access specification says:
   *
   *   "An INVALID_OPERATION error is generated by VertexArrayBindingDivisor
   *    if <vaobj> is not [compatibility profile: zero or] the name of an
   *    existing vertex array object."
   */
   vao = _mesa_lookup_vao_err(ctx, vaobj, true, "glVertexArrayVertexBindingDivisorEXT");
   if (!vao)
            vertex_array_binding_divisor(ctx, vao, bindingIndex, divisor,
      }
      /**
   * Print current vertex object/array info.  For debug.
   */
   void
   _mesa_print_arrays(struct gl_context *ctx)
   {
                        GLbitfield mask = vao->Enabled;
   while (mask) {
      const gl_vert_attrib i = u_bit_scan(&mask);
            const struct gl_vertex_buffer_binding *binding =
                  fprintf(stderr, "  %s: Ptr=%p, Type=%s, Size=%d, ElemSize=%u, "
         "Stride=%d, Buffer=%u(Size %lu)\n",
   gl_vert_attrib_name((gl_vert_attrib)i),
   array->Ptr, _mesa_enum_to_string(array->Format.User.Type),
   array->Format.User.Size,
         }
      /**
   * Initialize attributes of a vertex array within a vertex array object.
   * \param vao  the container vertex array object
   * \param index  which array in the VAO to initialize
   * \param size  number of components (1, 2, 3 or 4) per attribute
   * \param type  datatype of the attribute (GL_FLOAT, GL_INT, etc).
   */
   static void
   init_array(struct gl_context *ctx,
               {
      assert(index < ARRAY_SIZE(vao->VertexAttrib));
   struct gl_array_attributes *array = &vao->VertexAttrib[index];
   assert(index < ARRAY_SIZE(vao->BufferBinding));
            _mesa_set_vertex_format(&array->Format, size, type, GL_RGBA,
         array->Stride = 0;
   array->Ptr = NULL;
   array->RelativeOffset = 0;
   ASSERT_BITFIELD_SIZE(struct gl_array_attributes, BufferBindingIndex,
                  binding->Offset = 0;
   binding->Stride = array->Format._ElementSize;
   binding->BufferObj = NULL;
      }
      static void
   init_default_vao_state(struct gl_context *ctx)
   {
               vao->RefCount = 1;
            /* Init the individual arrays */
   for (unsigned i = 0; i < ARRAY_SIZE(vao->VertexAttrib); i++) {
      switch (i) {
   case VERT_ATTRIB_NORMAL:
      init_array(ctx, vao, VERT_ATTRIB_NORMAL, 3, GL_FLOAT);
      case VERT_ATTRIB_COLOR1:
      init_array(ctx, vao, VERT_ATTRIB_COLOR1, 3, GL_FLOAT);
      case VERT_ATTRIB_FOG:
      init_array(ctx, vao, VERT_ATTRIB_FOG, 1, GL_FLOAT);
      case VERT_ATTRIB_COLOR_INDEX:
      init_array(ctx, vao, VERT_ATTRIB_COLOR_INDEX, 1, GL_FLOAT);
      case VERT_ATTRIB_EDGEFLAG:
      init_array(ctx, vao, VERT_ATTRIB_EDGEFLAG, 1, GL_UNSIGNED_BYTE);
      case VERT_ATTRIB_POINT_SIZE:
      init_array(ctx, vao, VERT_ATTRIB_POINT_SIZE, 1, GL_FLOAT);
      default:
      init_array(ctx, vao, i, 4, GL_FLOAT);
                     }
      /**
   * Initialize vertex array state for given context.
   */
   void
   _mesa_init_varray(struct gl_context *ctx)
   {
               ctx->Array.DefaultVAO = _mesa_new_vao(ctx, 0);
   _mesa_reference_vao(ctx, &ctx->Array.VAO, ctx->Array.DefaultVAO);
   _mesa_set_draw_vao(ctx, ctx->Array.VAO);
               }
         /**
   * Callback for deleting an array object.  Called by _mesa_HashDeleteAll().
   */
   static void
   delete_arrayobj_cb(void *data, void *userData)
   {
      struct gl_vertex_array_object *vao = (struct gl_vertex_array_object *) data;
   struct gl_context *ctx = (struct gl_context *) userData;
      }
         /**
   * Free vertex array state for given context.
   */
   void
   _mesa_free_varray_data(struct gl_context *ctx)
   {
      _mesa_HashDeleteAll(ctx->Array.Objects, delete_arrayobj_cb, ctx);
      }
      void GLAPIENTRY
   _mesa_GetVertexArrayIntegervEXT(GLuint vaobj, GLenum pname, GLint *param)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object* vao;
   struct gl_buffer_object *buf;
            vao = _mesa_lookup_vao_err(ctx, vaobj, true,
         if (!vao)
            /* The EXT_direct_state_access spec says:
   *
   *    "For GetVertexArrayIntegervEXT, pname must be one of the "Get value" tokens
   *    in tables 6.6, 6.7, 6.8, and 6.9 that use GetIntegerv, IsEnabled, or
   *    GetPointerv for their "Get command" (so excluding the VERTEX_ATTRIB_*
   *    tokens)."
   */
   switch (pname) {
      /* Tokens using GetIntegerv */
   case GL_CLIENT_ACTIVE_TEXTURE:
      *param = GL_TEXTURE0_ARB + ctx->Array.ActiveTexture;
      case GL_VERTEX_ARRAY_SIZE:
      *param = vao->VertexAttrib[VERT_ATTRIB_POS].Format.User.Size;
      case GL_VERTEX_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_POS].Format.User.Type;
      case GL_VERTEX_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_POS].Stride;
      case GL_VERTEX_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_POS].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_COLOR_ARRAY_SIZE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR0].Format.User.Size;
      case GL_COLOR_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR0].Format.User.Type;
      case GL_COLOR_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR0].Stride;
      case GL_COLOR_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_COLOR0].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_EDGE_FLAG_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_EDGEFLAG].Stride;
      case GL_EDGE_FLAG_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_EDGEFLAG].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_INDEX_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Format.User.Type;
      case GL_INDEX_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR_INDEX].Stride;
      case GL_INDEX_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_COLOR_INDEX].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_NORMAL_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_NORMAL].Format.User.Type;
      case GL_NORMAL_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_NORMAL].Stride;
      case GL_NORMAL_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_NORMAL].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_TEXTURE_COORD_ARRAY_SIZE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Format.User.Size;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Format.User.Type;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].Stride;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_TEX(ctx->Array.ActiveTexture)].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_FOG_COORD_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_FOG].Format.User.Type;
      case GL_FOG_COORD_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_FOG].Stride;
      case GL_FOG_COORD_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_FOG].BufferObj;
   *param = buf ? buf->Name : 0;
      case GL_SECONDARY_COLOR_ARRAY_SIZE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR1].Format.User.Size;
      case GL_SECONDARY_COLOR_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR1].Format.User.Type;
      case GL_SECONDARY_COLOR_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_COLOR1].Stride;
      case GL_SECONDARY_COLOR_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_COLOR1].BufferObj;
               /* Tokens using IsEnabled */
   case GL_VERTEX_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_POS);
      case GL_COLOR_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_COLOR0);
      case GL_EDGE_FLAG_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_EDGEFLAG);
      case GL_INDEX_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_COLOR_INDEX);
      case GL_NORMAL_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_NORMAL);
      case GL_TEXTURE_COORD_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_TEX(ctx->Array.ActiveTexture));
      case GL_FOG_COORD_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_FOG);
      case GL_SECONDARY_COLOR_ARRAY:
                  /* Tokens using GetPointerv */
   case GL_VERTEX_ARRAY_POINTER:
   case GL_COLOR_ARRAY_POINTER:
   case GL_EDGE_FLAG_ARRAY_POINTER:
   case GL_INDEX_ARRAY_POINTER:
   case GL_NORMAL_ARRAY_POINTER:
   case GL_TEXTURE_COORD_ARRAY_POINTER:
   case GL_FOG_COORD_ARRAY_POINTER:
   case GL_SECONDARY_COLOR_ARRAY_POINTER:
      _get_vao_pointerv(pname, vao, &ptr, "glGetVertexArrayIntegervEXT");
               default:
         }
      void GLAPIENTRY
   _mesa_GetVertexArrayPointervEXT(GLuint vaobj, GLenum pname, GLvoid** param)
   {
      GET_CURRENT_CONTEXT(ctx);
            vao = _mesa_lookup_vao_err(ctx, vaobj, true,
         if (!vao)
            /* The EXT_direct_state_access spec says:
   *
   *     "For GetVertexArrayPointervEXT, pname must be a *_ARRAY_POINTER token from
   *     tables 6.6, 6.7, and 6.8 excluding VERTEX_ATTRIB_ARRAY_POINT."
   */
   switch (pname) {
      case GL_VERTEX_ARRAY_POINTER:
   case GL_COLOR_ARRAY_POINTER:
   case GL_EDGE_FLAG_ARRAY_POINTER:
   case GL_INDEX_ARRAY_POINTER:
   case GL_NORMAL_ARRAY_POINTER:
   case GL_TEXTURE_COORD_ARRAY_POINTER:
   case GL_FOG_COORD_ARRAY_POINTER:
   case GL_SECONDARY_COLOR_ARRAY_POINTER:
            default:
      _mesa_error(ctx, GL_INVALID_ENUM, "glGetVertexArrayPointervEXT(pname)");
            /* pname has been validated, we can now use the helper function */
      }
      void GLAPIENTRY
   _mesa_GetVertexArrayIntegeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLint *param)
   {
      GET_CURRENT_CONTEXT(ctx);
   struct gl_vertex_array_object* vao;
            vao = _mesa_lookup_vao_err(ctx, vaobj, true,
         if (!vao)
               /* The EXT_direct_state_access spec says:
   *
   *    "For GetVertexArrayIntegeri_vEXT, pname must be one of the
   *    "Get value" tokens in tables 6.8 and 6.9 that use GetVertexAttribiv
   *    or GetVertexAttribPointerv (so allowing only the VERTEX_ATTRIB_*
   *    tokens) or a token of the form TEXTURE_COORD_ARRAY (the enable) or
   *    TEXTURE_COORD_ARRAY_*; index identifies the vertex attribute
   *    array to query or texture coordinate set index respectively."
            switch (pname) {
      case GL_TEXTURE_COORD_ARRAY:
      *param = !!(vao->Enabled & VERT_BIT_TEX(index));
      case GL_TEXTURE_COORD_ARRAY_SIZE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(index)].Format.User.Size;
      case GL_TEXTURE_COORD_ARRAY_TYPE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(index)].Format.User.Type;
      case GL_TEXTURE_COORD_ARRAY_STRIDE:
      *param = vao->VertexAttrib[VERT_ATTRIB_TEX(index)].Stride;
      case GL_TEXTURE_COORD_ARRAY_BUFFER_BINDING:
      buf = vao->BufferBinding[VERT_ATTRIB_TEX(index)].BufferObj;
   *param = buf ? buf->Name : 0;
      default:
         }
      void GLAPIENTRY
   _mesa_GetVertexArrayPointeri_vEXT(GLuint vaobj, GLuint index, GLenum pname, GLvoid** param)
   {
      GET_CURRENT_CONTEXT(ctx);
            vao = _mesa_lookup_vao_err(ctx, vaobj, true,
         if (!vao)
            if (index >= ctx->Const.Program[MESA_SHADER_VERTEX].MaxAttribs) {
      _mesa_error(ctx, GL_INVALID_VALUE, "glGetVertexArrayPointeri_vEXT(index)");
               /* The EXT_direct_state_access spec says:
   *
   *     "For GetVertexArrayPointeri_vEXT, pname must be VERTEX_ATTRIB_ARRAY_POINTER
   *     or TEXTURE_COORD_ARRAY_POINTER with the index parameter indicating the vertex
   *     attribute or texture coordindate set index."
   */
   switch(pname) {
      case GL_VERTEX_ATTRIB_ARRAY_POINTER:
      *param = (GLvoid *) vao->VertexAttrib[VERT_ATTRIB_GENERIC(index)].Ptr;
      case GL_TEXTURE_COORD_ARRAY_POINTER:
      *param = (GLvoid *) vao->VertexAttrib[VERT_ATTRIB_TEX(index)].Ptr;
      default:
         }
