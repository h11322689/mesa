   /*
   * Copyright Â© 2016 Red Hat
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice (including the next
   * paragraph) shall be included in all copies or substantial portions of the
   * Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
      /* Lowers the additional tex_src_plane src, generated by nir_lower_tex
   * for planar YUV textures, into separate samplers, matching the logic
   * that mesa/st uses to insert additional sampler view/state (since both
   * sides need to agree).
   *
   * This should run after nir_lower_samplers.
   */
      #include "util/u_string.h"
   #include "compiler/nir/nir.h"
   #include "compiler/nir/nir_builder.h"
   #include "st_nir.h"
      typedef struct {
               unsigned lower_2plane;
            /* Maps a primary sampler (used for Y) to the U or UV sampler.  In
   * case of 3-plane YUV format, the V plane is next sampler after U.
   */
      } lower_tex_src_state;
      static nir_variable *
   find_sampler(lower_tex_src_state *state, unsigned samp)
   {
      /* NOTE: arrays of samplerExternalOES do not appear to be allowed: */
   nir_foreach_uniform_variable(var, state->shader)
      if (var->data.binding == samp)
         }
      static void
   add_sampler(lower_tex_src_state *state, unsigned orig_binding,
         {
      const struct glsl_type *samplerExternalOES =
         nir_variable *new_sampler, *orig_sampler =
                  UNUSED int r = asprintf(&name, "%s:%s", orig_sampler->name, ext);
   new_sampler = nir_variable_create(state->shader, nir_var_uniform,
                     }
      static void
   assign_extra_samplers(lower_tex_src_state *state, unsigned free_slots)
   {
               while (mask) {
               if (state->lower_3plane & (1 << y_samp)) {
      /* two additional planes (U and V): */
                                             } else {
      /* single additional UV plane: */
                           }
      static void
   lower_tex_src_plane_block(nir_builder *b, lower_tex_src_state *state, nir_block *block)
   {
      nir_foreach_instr(instr, block) {
      if (instr->type != nir_instr_type_tex)
            nir_tex_instr *tex = nir_instr_as_tex(instr);
            if (plane_index < 0)
            nir_const_value *plane = nir_src_as_const_value(tex->src[plane_index].src);
            if (plane[0].i32 > 0) {
      unsigned y_samp = tex->texture_index;
   int tex_index = nir_tex_instr_src_index(tex, nir_tex_src_texture_deref);
   if (tex_index >= 0) {
      nir_deref_instr *deref = nir_src_as_deref(tex->src[tex_index].src);
                              unsigned u_v_samp = state->sampler_map[y_samp][plane[0].i32 - 1];
                  /* For drivers using PIPE_CAP_NIR_SAMPLERS_AS_DEREF, we need
   * to reference the correct sampler nir variable.
   */
   int samp_index = nir_tex_instr_src_index(tex, nir_tex_src_sampler_deref);
                                                   nir_src_rewrite(&tex->src[tex_index].src, tex_deref);
      } else {
      /* For others we need to update texture_index */
   assume(tex->texture_index == tex->sampler_index);
                        }
      static void
   lower_tex_src_plane_impl(lower_tex_src_state *state, nir_function_impl *impl)
   {
               nir_foreach_block(block, impl) {
                  nir_metadata_preserve(impl, nir_metadata_block_index |
      }
      void
   st_nir_lower_tex_src_plane(struct nir_shader *shader, unsigned free_slots,
         {
               state.shader = shader;
   state.lower_2plane = lower_2plane;
                     nir_foreach_function_impl(impl, shader) {
            }
