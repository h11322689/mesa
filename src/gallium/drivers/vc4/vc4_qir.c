   /*
   * Copyright Â© 2014 Broadcom
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice (including the next
   * paragraph) shall be included in all copies or substantial portions of the
   * Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   */
      #include "util/u_memory.h"
   #include "util/ralloc.h"
      #include "vc4_qir.h"
   #include "vc4_qpu.h"
      struct qir_op_info {
         const char *name;
   uint8_t ndst, nsrc;
   };
      static const struct qir_op_info qir_op_info[] = {
         [QOP_MOV] = { "mov", 1, 1 },
   [QOP_FMOV] = { "fmov", 1, 1 },
   [QOP_MMOV] = { "mmov", 1, 1 },
   [QOP_FADD] = { "fadd", 1, 2 },
   [QOP_FSUB] = { "fsub", 1, 2 },
   [QOP_FMUL] = { "fmul", 1, 2 },
   [QOP_MUL24] = { "mul24", 1, 2 },
   [QOP_V8MULD] = {"v8muld", 1, 2 },
   [QOP_V8MIN] = {"v8min", 1, 2 },
   [QOP_V8MAX] = {"v8max", 1, 2 },
   [QOP_V8ADDS] = {"v8adds", 1, 2 },
   [QOP_V8SUBS] = {"v8subs", 1, 2 },
   [QOP_FMIN] = { "fmin", 1, 2 },
   [QOP_FMAX] = { "fmax", 1, 2 },
   [QOP_FMINABS] = { "fminabs", 1, 2 },
   [QOP_FMAXABS] = { "fmaxabs", 1, 2 },
   [QOP_FTOI] = { "ftoi", 1, 1 },
   [QOP_ITOF] = { "itof", 1, 1 },
   [QOP_ADD] = { "add", 1, 2 },
   [QOP_SUB] = { "sub", 1, 2 },
   [QOP_SHR] = { "shr", 1, 2 },
   [QOP_ASR] = { "asr", 1, 2 },
   [QOP_SHL] = { "shl", 1, 2 },
   [QOP_MIN] = { "min", 1, 2 },
   [QOP_MIN_NOIMM] = { "min_noimm", 1, 2 },
   [QOP_MAX] = { "max", 1, 2 },
   [QOP_AND] = { "and", 1, 2 },
   [QOP_OR] = { "or", 1, 2 },
   [QOP_XOR] = { "xor", 1, 2 },
            [QOP_RCP] = { "rcp", 1, 1 },
   [QOP_RSQ] = { "rsq", 1, 1 },
   [QOP_EXP2] = { "exp2", 1, 1 },
   [QOP_LOG2] = { "log2", 1, 1 },
   [QOP_TLB_COLOR_READ] = { "tlb_color_read", 1, 0 },
   [QOP_MS_MASK] = { "ms_mask", 0, 1, true },
            [QOP_FRAG_Z] = { "frag_z", 1, 0 },
                              [QOP_LOAD_IMM] = { "load_imm", 0, 1 },
   [QOP_LOAD_IMM_U2] = { "load_imm_u2", 0, 1 },
                     [QOP_BRANCH] = { "branch", 0, 0, true },
   };
      static const char *
   qir_get_op_name(enum qop qop)
   {
         if (qop < ARRAY_SIZE(qir_op_info) && qir_op_info[qop].name)
         else
   }
      int
   qir_get_non_sideband_nsrc(struct qinst *inst)
   {
         assert(qir_op_info[inst->op].name);
   }
      int
   qir_get_nsrc(struct qinst *inst)
   {
                           /* Normal (non-direct) texture coordinate writes also implicitly load
      * a uniform for the texture parameters.
      if (qir_is_tex(inst) && inst->dst.file != QFILE_TEX_S_DIRECT)
            }
      /* The sideband uniform for textures gets stored after the normal ALU
   * arguments.
   */
   int
   qir_get_tex_uniform_src(struct qinst *inst)
   {
         }
      /**
   * Returns whether the instruction has any side effects that must be
   * preserved.
   */
   bool
   qir_has_side_effects(struct vc4_compile *c, struct qinst *inst)
   {
         switch (inst->dst.file) {
   case QFILE_TLB_Z_WRITE:
   case QFILE_TLB_COLOR_WRITE:
   case QFILE_TLB_COLOR_WRITE_MS:
   case QFILE_TLB_STENCIL_SETUP:
   case QFILE_TEX_S_DIRECT:
   case QFILE_TEX_S:
   case QFILE_TEX_T:
   case QFILE_TEX_R:
   case QFILE_TEX_B:
         default:
                  }
      bool
   qir_has_side_effect_reads(struct vc4_compile *c, struct qinst *inst)
   {
         /* We can dead-code eliminate varyings, because we only tell the VS
      * about the live ones at the end.  But we have to preserve the
   * point/line coordinates reads, because they're generated by
   * fixed-function hardware.
      for (int i = 0; i < qir_get_nsrc(inst); i++) {
            if (inst->src[i].file == QFILE_VARY &&
                                    if (inst->dst.file == QFILE_VPM)
            }
      bool
   qir_has_uniform_read(struct qinst *inst)
   {
         for (int i = 0; i < qir_get_nsrc(inst); i++) {
                        }
      bool
   qir_is_mul(struct qinst *inst)
   {
         switch (inst->op) {
   case QOP_MMOV:
   case QOP_FMUL:
   case QOP_MUL24:
   case QOP_V8MULD:
   case QOP_V8MIN:
   case QOP_V8MAX:
   case QOP_V8ADDS:
   case QOP_V8SUBS:
   case QOP_ROT_MUL:
         default:
         }
      bool
   qir_is_float_input(struct qinst *inst)
   {
         switch (inst->op) {
   case QOP_FMOV:
   case QOP_FMUL:
   case QOP_FADD:
   case QOP_FSUB:
   case QOP_FMIN:
   case QOP_FMAX:
   case QOP_FMINABS:
   case QOP_FMAXABS:
   case QOP_FTOI:
         default:
         }
      bool
   qir_is_raw_mov(struct qinst *inst)
   {
         return ((inst->op == QOP_MOV ||
            inst->op == QOP_FMOV ||
   inst->op == QOP_MMOV) &&
      }
      bool
   qir_is_tex(struct qinst *inst)
   {
         switch (inst->dst.file) {
   case QFILE_TEX_S_DIRECT:
   case QFILE_TEX_S:
   case QFILE_TEX_T:
   case QFILE_TEX_R:
   case QFILE_TEX_B:
         default:
         }
      bool
   qir_has_implicit_tex_uniform(struct qinst *inst)
   {
         switch (inst->dst.file) {
   case QFILE_TEX_S:
   case QFILE_TEX_T:
   case QFILE_TEX_R:
   case QFILE_TEX_B:
         default:
         }
      bool
   qir_depends_on_flags(struct qinst *inst)
   {
         if (inst->op == QOP_BRANCH) {
         } else {
               }
      bool
   qir_writes_r4(struct qinst *inst)
   {
         switch (inst->op) {
   case QOP_TEX_RESULT:
   case QOP_TLB_COLOR_READ:
   case QOP_RCP:
   case QOP_RSQ:
   case QOP_EXP2:
   case QOP_LOG2:
         default:
         }
      uint8_t
   qir_channels_written(struct qinst *inst)
   {
         if (qir_is_mul(inst)) {
            switch (inst->dst.pack) {
   case QPU_PACK_MUL_NOP:
   case QPU_PACK_MUL_8888:
         case QPU_PACK_MUL_8A:
         case QPU_PACK_MUL_8B:
         case QPU_PACK_MUL_8C:
         case QPU_PACK_MUL_8D:
      } else {
            switch (inst->dst.pack) {
   case QPU_PACK_A_NOP:
   case QPU_PACK_A_8888:
   case QPU_PACK_A_8888_SAT:
   case QPU_PACK_A_32_SAT:
         case QPU_PACK_A_8A:
   case QPU_PACK_A_8A_SAT:
         case QPU_PACK_A_8B:
   case QPU_PACK_A_8B_SAT:
         case QPU_PACK_A_8C:
   case QPU_PACK_A_8C_SAT:
         case QPU_PACK_A_8D:
   case QPU_PACK_A_8D_SAT:
         case QPU_PACK_A_16A:
   case QPU_PACK_A_16A_SAT:
         case QPU_PACK_A_16B:
   case QPU_PACK_A_16B_SAT:
      }
   }
      char *
   qir_describe_uniform(enum quniform_contents contents, uint32_t data,
         {
         static const char *quniform_names[] = {
            [QUNIFORM_VIEWPORT_X_SCALE] = "vp_x_scale",
   [QUNIFORM_VIEWPORT_Y_SCALE] = "vp_y_scale",
   [QUNIFORM_VIEWPORT_Z_OFFSET] = "vp_z_offset",
   [QUNIFORM_VIEWPORT_Z_SCALE] = "vp_z_scale",
   [QUNIFORM_TEXTURE_CONFIG_P0] = "tex_p0",
   [QUNIFORM_TEXTURE_CONFIG_P1] = "tex_p1",
               switch (contents) {
   case QUNIFORM_CONSTANT:
         case QUNIFORM_UNIFORM:
            if (uniforms) {
            uint32_t unif = uniforms[data];
                  case QUNIFORM_TEXTURE_CONFIG_P0:
   case QUNIFORM_TEXTURE_CONFIG_P1:
   case QUNIFORM_TEXTURE_CONFIG_P2:
   case QUNIFORM_TEXTURE_FIRST_LEVEL:
                  default:
            if (contents < ARRAY_SIZE(quniform_names) &&
      quniform_names[contents]) {
            } else {
      }
      static void
   qir_print_reg(struct vc4_compile *c, struct qreg reg, bool write)
   {
         static const char *files[] = {
            [QFILE_TEMP] = "t",
   [QFILE_VARY] = "v",
   [QFILE_TLB_COLOR_WRITE] = "tlb_c",
   [QFILE_TLB_COLOR_WRITE_MS] = "tlb_c_ms",
   [QFILE_TLB_Z_WRITE] = "tlb_z",
   [QFILE_TLB_STENCIL_SETUP] = "tlb_stencil",
   [QFILE_FRAG_X] = "frag_x",
   [QFILE_FRAG_Y] = "frag_y",
   [QFILE_FRAG_REV_FLAG] = "frag_rev_flag",
   [QFILE_QPU_ELEMENT] = "elem",
   [QFILE_TEX_S_DIRECT] = "tex_s_direct",
   [QFILE_TEX_S] = "tex_s",
   [QFILE_TEX_T] = "tex_t",
                        case QFILE_NULL:
                  case QFILE_LOAD_IMM:
                  case QFILE_SMALL_IMM:
            if ((int)reg.index >= -16 && (int)reg.index <= 15)
                     case QFILE_VPM:
            if (write) {
         } else {
                     case QFILE_TLB_COLOR_WRITE:
   case QFILE_TLB_COLOR_WRITE_MS:
   case QFILE_TLB_Z_WRITE:
   case QFILE_TLB_STENCIL_SETUP:
   case QFILE_TEX_S_DIRECT:
   case QFILE_TEX_S:
   case QFILE_TEX_T:
   case QFILE_TEX_R:
   case QFILE_TEX_B:
                  case QFILE_UNIF: {
            char *desc = qir_describe_uniform(c->uniform_contents[reg.index],
               fprintf(stderr, "u%d (%s)", reg.index, desc);
               default:
               }
      void
   qir_dump_inst(struct vc4_compile *c, struct qinst *inst)
   {
         fprintf(stderr, "%s", qir_get_op_name(inst->op));
   if (inst->op == QOP_BRANCH)
         else
         if (inst->sf)
                  if (inst->op != QOP_BRANCH) {
            qir_print_reg(c, inst->dst, true);
   if (inst->dst.pack) {
            if (inst->dst.pack) {
         if (qir_is_mul(inst))
                  for (int i = 0; i < qir_get_nsrc(inst); i++) {
            fprintf(stderr, ", ");
      }
      void
   qir_dump(struct vc4_compile *c)
   {
         int ip = 0;
            qir_for_each_block(block, c) {
            fprintf(stderr, "BLOCK %d:\n", block->index);
                                                                              if (first) {
                                                                                                                     if (first) {
                                                                  qir_dump_inst(c, inst);
      }
   if (block->successors[1]) {
            fprintf(stderr, "-> BLOCK %d, %d\n",
      } else if (block->successors[0]) {
            }
      struct qreg
   qir_get_temp(struct vc4_compile *c)
   {
                  reg.file = QFILE_TEMP;
   reg.index = c->num_temps++;
            if (c->num_temps > c->defs_array_size) {
            uint32_t old_size = c->defs_array_size;
   c->defs_array_size = MAX2(old_size * 2, 16);
   c->defs = reralloc(c, c->defs, struct qinst *,
                     }
      struct qinst *
   qir_inst(enum qop op, struct qreg dst, struct qreg src0, struct qreg src1)
   {
                  inst->op = op;
   inst->dst = dst;
   inst->src[0] = src0;
   inst->src[1] = src1;
            }
      static void
   qir_emit(struct vc4_compile *c, struct qinst *inst)
   {
         }
      /* Updates inst to write to a new temporary, emits it, and notes the def. */
   struct qreg
   qir_emit_def(struct vc4_compile *c, struct qinst *inst)
   {
                           if (inst->dst.file == QFILE_TEMP)
                     }
      struct qinst *
   qir_emit_nondef(struct vc4_compile *c, struct qinst *inst)
   {
         if (inst->dst.file == QFILE_TEMP)
                     }
      bool
   qir_reg_equals(struct qreg a, struct qreg b)
   {
         }
      struct qblock *
   qir_new_block(struct vc4_compile *c)
   {
                  list_inithead(&block->instructions);
            block->predecessors = _mesa_set_create(block,
                           }
      void
   qir_set_emit_block(struct vc4_compile *c, struct qblock *block)
   {
         c->cur_block = block;
   }
      struct qblock *
   qir_entry_block(struct vc4_compile *c)
   {
         }
      struct qblock *
   qir_exit_block(struct vc4_compile *c)
   {
         }
      void
   qir_link_blocks(struct qblock *predecessor, struct qblock *successor)
   {
         _mesa_set_add(successor->predecessors, predecessor);
   if (predecessor->successors[0]) {
               } else {
         }
      struct vc4_compile *
   qir_compile_init(void)
   {
                  list_inithead(&c->blocks);
   qir_set_emit_block(c, qir_new_block(c));
            c->output_position_index = -1;
   c->output_color_index = -1;
   c->output_point_size_index = -1;
            c->def_ht = _mesa_hash_table_create(c, _mesa_hash_pointer,
            }
      void
   qir_remove_instruction(struct vc4_compile *c, struct qinst *qinst)
   {
         if (qinst->dst.file == QFILE_TEMP)
            list_del(&qinst->link);
   }
      struct qreg
   qir_follow_movs(struct vc4_compile *c, struct qreg reg)
   {
                  while (reg.file == QFILE_TEMP &&
            c->defs[reg.index] &&
   (c->defs[reg.index]->op == QOP_MOV ||
   c->defs[reg.index]->op == QOP_FMOV ||
   c->defs[reg.index]->op == QOP_MMOV)&&
   !c->defs[reg.index]->dst.pack &&
               reg.pack = pack;
   }
      void
   qir_compile_destroy(struct vc4_compile *c)
   {
         qir_for_each_block(block, c) {
            while (!list_is_empty(&block->instructions)) {
            struct qinst *qinst =
                  }
      const char *
   qir_get_stage_name(enum qstage stage)
   {
         static const char *names[] = {
            [QSTAGE_FRAG] = "MESA_SHADER_FRAGMENT",
               }
      struct qreg
   qir_uniform(struct vc4_compile *c,
               {
         for (int i = 0; i < c->num_uniforms; i++) {
            if (c->uniform_contents[i] == contents &&
      c->uniform_data[i] == data) {
                     if (uniform >= c->uniform_array_size) {
                           c->uniform_data = reralloc(c, c->uniform_data,
               c->uniform_contents = reralloc(c, c->uniform_contents,
               c->uniform_contents[uniform] = contents;
            }
      void
   qir_SF(struct vc4_compile *c, struct qreg src)
   {
                  if (!list_is_empty(&c->cur_block->instructions))
            /* We don't have any way to guess which kind of MOV is implied. */
            if (src.file != QFILE_TEMP ||
         !c->defs[src.index] ||
   last_inst != c->defs[src.index]) {
   }
   }
      #define OPTPASS(func)                                                   \
         do {                                                            \
            bool stage_progress = func(c);                          \
   if (stage_progress) {                                   \
            progress = true;                                \
   if (print_opt_debug) {                          \
         fprintf(stderr,                         \
            void
   qir_optimize(struct vc4_compile *c)
   {
         bool print_opt_debug = false;
            while (true) {
                     OPTPASS(qir_opt_algebraic);
   OPTPASS(qir_opt_constant_folding);
   OPTPASS(qir_opt_copy_propagation);
   OPTPASS(qir_opt_peephole_sf);
   OPTPASS(qir_opt_dead_code);
                                    }
