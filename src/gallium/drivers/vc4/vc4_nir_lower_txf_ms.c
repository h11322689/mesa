   /*
   * Copyright Â© 2015 Broadcom
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * the rights to use, copy, modify, merge, publish, distribute, sublicense,
   * and/or sell copies of the Software, and to permit persons to whom the
   * Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice (including the next
   * paragraph) shall be included in all copies or substantial portions of the
   * Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
   * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
   * IN THE SOFTWARE.
   */
      #include "vc4_qir.h"
   #include "kernel/vc4_packet.h"
   #include "compiler/nir/nir_builder.h"
      /** @file vc4_nir_lower_txf_ms.c
   * Walks the NIR generated by TGSI-to-NIR to lower its nir_texop_txf_ms
   * coordinates to do the math necessary and use a plain nir_texop_txf instead.
   *
   * MSAA textures are laid out as 32x32-aligned blocks of RGBA8888 or Z24S8.
   * We can't load them through the normal sampler path because of the lack of
   * linear support in the hardware.  So, we treat MSAA textures as a giant UBO
   * and do the math in the shader.
   */
      static nir_def *
   vc4_nir_lower_txf_ms_instr(nir_builder *b, nir_instr *instr, void *data)
   {
         nir_tex_instr *txf_ms = nir_instr_as_tex(instr);
            nir_tex_instr *txf = nir_tex_instr_create(c->s, 1);
   txf->op = nir_texop_txf;
   txf->texture_index = txf_ms->texture_index;
   txf->coord_components = txf_ms->coord_components;
   txf->is_shadow = txf_ms->is_shadow;
   txf->is_new_style_shadow = txf_ms->is_new_style_shadow;
            nir_def *coord = NULL, *sample_index = NULL;
   for (int i = 0; i < txf_ms->num_srcs; i++) {
            switch (txf_ms->src[i].src_type) {
   case nir_tex_src_coord:
               case nir_tex_src_ms_index:
               default:
      }
   assert(coord);
            nir_def *x = nir_channel(b, coord, 0);
            uint32_t tile_w = 32;
   uint32_t tile_h = 32;
   uint32_t tile_w_shift = 5;
   uint32_t tile_h_shift = 5;
   uint32_t tile_size = (tile_h * tile_w *
         unsigned unit = txf_ms->texture_index;
   uint32_t w = align(c->key->tex[unit].msaa_width, tile_w);
            nir_def *x_tile = nir_ushr_imm(b, x, tile_w_shift);
   nir_def *y_tile = nir_ushr_imm(b, y, tile_h_shift);
   nir_def *tile_addr = nir_iadd(b,
                     nir_def *x_subspan = nir_iand_imm(b, x, (tile_w - 1) & ~1);
   nir_def *y_subspan = nir_iand_imm(b, y, (tile_h - 1) & ~1);
   nir_def *subspan_addr = nir_iadd(b,
                                    nir_def *pixel_addr = nir_ior(b,
                                                   nir_def *addr = nir_iadd(b,
                  txf->src[0] = nir_tex_src_for_ssa(nir_tex_src_coord,
         nir_def_init(&txf->instr, &txf->def, 4, 32);
            }
      static bool
   vc4_nir_lower_txf_ms_filter(const nir_instr *instr, const void *data)
   {
         return (instr->type == nir_instr_type_tex &&
   }
      void
   vc4_nir_lower_txf_ms(nir_shader *s, struct vc4_compile *c)
   {
         nir_shader_lower_instructions(s,
               }
