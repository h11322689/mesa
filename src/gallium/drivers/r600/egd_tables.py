   CopyRight = '''
   /*
   * Copyright 2015 Advanced Micro Devices, Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a
   * copy of this software and associated documentation files (the "Software"),
   * to deal in the Software without restriction, including without limitation
   * on the rights to use, copy, modify, merge, publish, distribute, sub
   * license, and/or sell copies of the Software, and to permit persons to whom
   * the Software is furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice (including the next
   * paragraph) shall be included in all copies or substantial portions of the
   * Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
   * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
   * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
   * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
   * USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   */
   '''
      import sys
   import re
         class StringTable:
      """
   A class for collecting multiple strings in a single larger string that is
   used by indexing (to avoid relocations in the resulting binary)
   """
   def __init__(self):
      self.table = []
         def add(self, string):
      # We might get lucky with string being a suffix of a previously added string
   for te in self.table:
         if te[0].endswith(string):
                  idx = self.length
   self.table.append((string, idx, set((idx,))))
                  def emit(self, filp, name, static=True):
      """
   Write
   [static] const char name[] = "...";
   to filp.
   """
   fragments = [
         '"%s\\0" /* %s */' % (
      te[0].encode('unicode_escape').decode(),
      )
   ]
   filp.write('%sconst char %s[] =\n%s;\n' % (
         'static ' if static else '',
   name,
      class IntTable:
      """
   A class for collecting multiple arrays of integers in a single big array
   that is used by indexing (to avoid relocations in the resulting binary)
   """
   def __init__(self, typename):
      self.typename = typename
   self.table = []
         def add(self, array):
      # We might get lucky and find the array somewhere in the existing data
   try:
         idx = 0
                     for i in range(1, len(array)):
      if array[i] != self.table[idx + i]:
                        except ValueError:
            idx = len(self.table)
   self.table += array
   self.idxs.add(idx)
         def emit(self, filp, name, static=True):
      """
   Write
   [static] const typename name[] = { ... };
   to filp.
   """
            fragments = [
         ('\t/* %s */ %s' % (
      idxs[i],
      ))
            filp.write('%sconst %s %s[] = {\n%s\n};\n' % (
         'static ' if static else '',
   self.typename, name,
      class Field:
      def __init__(self, reg, s_name):
      self.s_name = s_name
   self.name = strip_prefix(s_name)
   self.values = []
      class Reg:
      def __init__(self, r_name):
      self.r_name = r_name
   self.name = strip_prefix(r_name)
   self.fields = []
         def strip_prefix(s):
      '''Strip prefix in the form ._.*_, e.g. R_001234_'''
         def parse(filename, regs, packets):
               for line in stream:
      if not line.startswith('#define '):
                     if line.startswith('R_'):
                  for it in regs:
      if it.r_name == name:
      reg = it
   else:
            elif line.startswith('S_'):
                  for it in reg.fields:
      if it.s_name == name:
      field = it
   else:
            elif line.startswith('V_'):
         split = line.split()
                  for (n,v) in field.values:
                           elif line.startswith('PKT3_') and line.find('0x') != -1 and line.find('(') == -1:
         # Copy fields to indexed registers which have their fields only defined
   # at register index 0.
   # For example, copy fields from CB_COLOR0_INFO to CB_COLORn_INFO, n > 0.
   match_number = re.compile('[0-9]+')
            # Create a dict of registers with fields and '0' in their name
   for reg in regs:
      if len(reg.fields) and reg.name.find('0') != -1:
         # Assign fields
   for reg in regs:
      if not len(reg.fields):
         reg0 = reg_dict.get(match_number.sub('0', reg.name))
   if reg0 != None:
               def write_tables(regs, packets):
         strings = StringTable()
            print('/* This file is autogenerated by egd_tables.py from evergreend.h. Do not edit directly. */')
   print()
   print(CopyRight.strip())
      #ifndef EG_TABLES_H
   #define EG_TABLES_H
      struct eg_field {
         unsigned name_offset;
   unsigned mask;
   unsigned num_values;
   };
      struct eg_reg {
         unsigned name_offset;
   unsigned offset;
   unsigned num_fields;
   };
      struct eg_packet3 {
         unsigned name_offset;
   };
   ''')
         print('static const struct eg_packet3 packet3_table[] = {')
   for pkt in packets:
         print('};')
                     fields_idx = 0
   for reg in regs:
      if len(reg.fields) and reg.own_fields:
                           for field in reg.fields:
      if len(field.values):
      values_offsets = []
   for value in field.values:
         while value[1] >= len(values_offsets):
         print('\t{%s, %s(~0u), %s, %s},' % (
                     print('};')
            print('static const struct eg_reg egd_reg_table[] = {')
   for reg in regs:
      if len(reg.fields):
         print('\t{%s, %s, %s, %s},' % (strings.add(reg.name), reg.r_name,
   else:
      print('};')
                                       print()
            def main():
      regs = []
   packets = []
   for arg in sys.argv[1:]:
                  if __name__ == '__main__':
            # kate: space-indent on; indent-width 4; replace-tabs on;
